****# 캐싱 처리 (Cache Management)

## 개요

파일 서버의 캐싱 시스템은 SeaweedFS를 캐시 저장소로 사용하며, NAS(영구 저장소)와 분리된 2-tier 아키텍처로 설계되어 있습니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│  [캐싱 아키텍처]                                                      │
│                                                                     │
│  ┌───────────────┐         ┌───────────────┐         ┌───────────┐ │
│  │    Client     │ ──────→ │   SeaweedFS   │ ──────→ │    NAS    │ │
│  │   (사용자)    │         │   (캐시)      │         │  (영구)   │ │
│  └───────────────┘         └───────────────┘         └───────────┘ │
│                                    │                                │
│                                    │ Eviction                      │
│                                    ▼                                │
│                           ┌───────────────┐                        │
│                           │ EvictionWorker│                        │
│                           │  (주기적 정리)│                        │
│                           └───────────────┘                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 캐싱 정책 (Eviction Policy)

### 지원 정책

| 정책 | 설명 | 기준 필드 | 사용 케이스 |
|------|------|----------|------------|
| **LRU** | Least Recently Used - 가장 오래 접근되지 않은 파일 우선 삭제 | `lastAccessed` | 최근 사용된 파일이 다시 사용될 가능성 높을 때 |
| **LFU** | Least Frequently Used - 가장 적게 사용된 파일 우선 삭제 | `accessCount` | 자주 사용되는 파일 보존이 중요할 때 |
| **FIFO** | First In First Out - 가장 먼저 캐시된 파일 우선 삭제 | `createdAt` | 단순한 정책, 시간 기반 순환 필요 시 |

### 정책 선택 기준

```
┌─────────────────────────────────────────────────────────────────────┐
│  [정책 선택 가이드]                                                   │
│                                                                     │
│  LRU (기본값 권장):                                                  │
│  - 최근 접근 파일 = 다시 접근 가능성 높음 가정                        │
│  - 대부분의 파일 서버에 적합                                         │
│  - 핫 데이터 보존에 효과적                                           │
│                                                                     │
│  LFU:                                                               │
│  - 접근 빈도 기반                                                    │
│  - 특정 파일이 반복적으로 사용되는 환경에 적합                        │
│  - 주의: 초기 인기 파일이 오래 남을 수 있음                           │
│                                                                     │
│  FIFO:                                                              │
│  - 단순 구현, 예측 가능한 동작                                       │
│  - 모든 파일이 균등하게 사용되는 환경에 적합                          │
│  - 캐시 순환이 중요한 경우                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---


### file_storage_objects 접근 통계 필드 (캐시 전용)

```
file_storage_objects 테이블 (storageType = 'CACHE_SEAWEED')

lastAccessed (마지막 접근 시각)
  - 다운로드/미리보기 시 NOW()로 업데이트
  - LRU 정책에서 eviction 대상 선정 기준
  - CACHE_SEAWEED 레코드에서만 의미 있음

accessCount (접근 횟수)
  - 다운로드/미리보기 시 +1 증가
  - LFU 정책에서 eviction 대상 선정 기준
  - 기본값: 1 (캐시 생성 시점 = 첫 접근)

leaseCount (읽기 중 삭제 방지)
  - 현재 파일을 읽고 있는 클라이언트 수
  - 다운로드/미리보기 시작 시 +1, 완료/실패 시 -1 (atomic)
  - leaseCount > 0인 파일은 Eviction 대상에서 제외
  - 기본값: 0
```

---

## Eviction Worker (캐시 제거 워커)

### 개요

주기적으로 캐시 사용량을 확인하고 임계값 초과 시 파일을 제거하는 백그라운드 워커입니다.

```
참조: appServer/src/workers/eviction/eviction.worker.ts
```

### 실행 주기

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Eviction Worker 스케줄]                                            │
│                                                                     │
│  주기: 매 10분마다 (@Cron(CronExpression.EVERY_MINUTE))              │
│                                                                     │
│  동작:                                                               │
│  1. 이전 작업 진행 중이면 건너뜀 (중복 실행 방지)                     │
│  2. 캐시 서버 헬스 체크                                              │
│  3. 현재 캐시 사용량 조회                                            │
│  4. 임계값(80%) 초과 시 eviction 실행                                │
│  5. 목표(70%)까지 파일 제거                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Eviction 처리 플로우]                                               │
│                                                                     │
│  1. 헬스 체크                                                        │
│     if (!cashService.isHealthy()) → 작업 건너뜀                      │
│                                                                     │
│  2. 사용량 확인                                                       │
│     totalCachedSize = file_storage_objects 캐시 크기 합계            │
│     maxCacheSize = cache_settings.maxCacheSizeBytes                 │
│     usagePercent = (totalCachedSize / maxCacheSize) * 100           │
│                                                                     │
│  3. 임계값 체크                                                       │
│     if (usagePercent < thresholdPercent) → 작업 불필요               │
│                                                                     │
│  4. 목표 계산                                                         │
│     targetSize = maxCacheSize * (thresholdPercent - 10) / 100       │
│     spaceToFree = totalCachedSize - targetSize                      │
│                                                                     │
│  5. 파일 제거 루프                                                    │
│     while (freedSpace < spaceToFree):                               │
│       candidates = evictionPolicyService.getEvictionCandidates()    │
│       for each candidate:                                            │
│         ★atomic mark: lease=0 체크 후 EVICTING 전환★                 │
│         evictSingleFile(candidate)                                   │
│         freedSpace += candidate.size                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 단일 파일 제거 (트랜잭션 처리)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [evictSingleFile - 의사 트랜잭션]                                    │
│                                                                     │
│  1. NAS 동기화 확인                                                   │
│     if (!fileDocument.canBeEvicted())                                │
│       throw Error("NAS에 동기화되지 않은 파일은 제거 불가")           │
│                                                                     │
│  2. ★Atomic Mark: lease=0 체크 + EVICTING 전환★                       │
│     UPDATE file_storage_objects                                     │
│     SET availabilityStatus = 'EVICTING'                             │
│     WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'              │
│       AND availabilityStatus = 'AVAILABLE'                          │
│       AND leaseCount = 0                                            │
│     -- 영향받은 row = 0 → 누군가 읽는 중 → 건너뜀                    │
│     -- 영향받은 row = 1 → 안전하게 삭제 진행                         │
│                                                                     │
│  3. 원본 캐시 상태 백업 (롤백용)                                      │
│     cacheStateBackup = fileDocument.backupCacheState()              │
│                                                                     │
│  4. 캐시 삭제 진행 (EVICTING 상태)                                    │
│     -- 이 시점에 새 읽기 요청은 EVICTING 상태 확인 후 대기/NAS 조회  │
│                                                                     │
│  5. 캐시 서버에서 파일 삭제                                           │
│     try:                                                             │
│       await cashService.파일을_완전삭제한다(storedName)              │
│       # 성공: file_storage_objects 레코드 삭제 또는 EVICTED 상태     │
│       emit('cache.evicted', {...})                                   │
│     catch (cacheError):                                              │
│       # ★ 캐시 삭제 실패 → DB 롤백 (EVICTING → AVAILABLE) ★          │
│       UPDATE file_storage_objects                                   │
│       SET availabilityStatus = 'AVAILABLE'                          │
│       WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'            │
│       fileDocument.restoreCacheState(cacheStateBackup)              │
│       await fileDocumentRepository.save(fileDocument)               │
│       throw cacheError                                               │
│       # 관리자 알림 처리                                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Eviction 결과 (EvictionResult)

```typescript
interface EvictionResult {
  evictedCount: number;    // 제거된 파일 수
  freedSpace: number;      // 확보된 공간 (bytes)
  errors: {                // 실패한 파일 목록
    fileId: string;
    error: string;
  }[];
  duration: number;        // 소요 시간 (ms)
}
```

---

## Eviction Policy Service (캐시 제거 정책 서비스)

### 개요

현재 설정된 정책에 따라 제거 대상 파일을 조회하는 서비스입니다.

```
참조: appServer/src/workers/eviction/eviction-policy.service.ts
```

### 제거 대상 조회 쿼리 (정책별)

```sql
-- LRU (Least Recently Used)
SELECT * FROM file_storage_objects
WHERE storageType = 'CACHE_SEAWEED'
  AND availabilityStatus = 'AVAILABLE'
  AND leaseCount = 0           -- ★읽기 중인 파일 제외★
  AND nasStatus = 'AVAILABLE'  -- NAS에 동기화된 파일만
ORDER BY lastAccessed ASC      -- 오래된 접근 순
LIMIT :batchSize;

-- LFU (Least Frequently Used)
SELECT * FROM file_storage_objects
WHERE storageType = 'CACHE_SEAWEED'
  AND availabilityStatus = 'AVAILABLE'
  AND leaseCount = 0           -- ★읽기 중인 파일 제외★
  AND nasStatus = 'AVAILABLE'
ORDER BY accessCount ASC       -- 적은 접근 횟수 순
LIMIT :batchSize;

-- FIFO (First In First Out)
SELECT * FROM file_storage_objects
WHERE storageType = 'CACHE_SEAWEED'
  AND availabilityStatus = 'AVAILABLE'
  AND leaseCount = 0           -- ★읽기 중인 파일 제외★
  AND nasStatus = 'AVAILABLE'
ORDER BY createdAt ASC         -- 오래된 생성 순
LIMIT :batchSize;
```

### 제거 대상 조건

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Eviction 대상 조건]                                                 │
│                                                                     │
│  ✅ 제거 가능:                                                       │
│     - storageType = 'CACHE_SEAWEED' (캐시 파일)                      │
│     - availabilityStatus = 'AVAILABLE' (정상 상태)                   │
│     - leaseCount = 0 (★읽기 중이 아님★)                              │
│     - NAS에 동기화 완료된 파일                                        │
│                                                                     │
│  ❌ 제거 불가:                                                       │
│     - leaseCount > 0 (★누군가 읽고 있는 파일★)                       │
│     - NAS에 동기화되지 않은 파일 (유일한 복사본)                      │
│     - availabilityStatus = 'SYNCING' (동기화 중)                     │
│     - availabilityStatus = 'EVICTING' (삭제 진행 중)                 │
│     - availabilityStatus = 'ERROR' (오류 상태)                       │
│     - storageType = 'NAS' (영구 저장소)                              │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## API 엔드포인트

### 1. 캐시 설정 조회

```
GET /admin/cache-setting

Response:
{
  "success": true,
  "data": {
    "maxCacheSizeBytes": 9474836480,
    "evictionPolicy": "LRU",
    "policyDescription": "LRU (Least Recently Used): 가장 오래 접근되지 않은 파일을 우선 제거합니다.",
    "stats": {
      "policy": "LRU",
      "policyDescription": "LRU (Least Recently Used): ...",
      "batchSize": 100,
      "cachedFileCount": 22,
      "totalCachedSize": 7516255879,
      "evictionCandidatesCount": 10
    }
  },
  "timestamp": "2026-01-19T02:35:28.078Z"
}
```

### 2. 캐시 설정 수정

```
PUT /admin/cache-setting

Request Body:
{
  "maxCacheSizeBytes": 10737418240,  // 10GB
  "evictionPolicy": "LRU",
  "thresholdPercent": 80,
  "batchSize": 100
}

Response:
{
  "success": true,
  "message": "캐시 설정이 업데이트되었습니다.",
  "data": { ... }
}
```

### 3. 캐시 사용 현황 조회

```
GET /admin/cache-usage

Response:
{
  "success": true,
  "data": {
    "currentSize": 7516255879,
    "maxSize": 9474836480,
    "usagePercent": 79.35,
    "threshold": 80,
    "policy": "LRU",
    "cachedFileCount": 22
  }
}
```

### 4. 수동 캐시 정리 (Eviction)

```
POST /admin/cache-evict

Request Body (optional):
{
  "targetPercent": 50  // 기본값: 70
}

Response:
{
  "success": true,
  "data": {
    "evictedCount": 5,
    "freedSpace": 1073741824,
    "errors": [],
    "duration": 2500
  }
}
```

### 5. 특정 파일 강제 제거

```
DELETE /admin/cache-evict/:fileId

Response:
{
  "success": true,
  "message": "파일이 캐시에서 제거되었습니다.",
  "data": {
    "fileId": "uuid",
    "fileName": "document.pdf",
    "freedSpace": 10485760
  }
}
```

---

## 캐싱 서버 헬스 체크

### 헬스 체크 플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [캐싱 서버 헬스 체크]                                                │
│                                                                     │
│  1. EvictionWorker 실행 시 매번 체크                                 │
│     cashService.isHealthy() → boolean                               │
│                                                                     │
│  2. 헬스 체크 방식:                                                  │
│     - SeaweedFS 연결 상태 확인                                       │
│     - 간단한 읽기/쓰기 테스트                                        │
│                                                                     │
│  3. 비정상 시:                                                       │
│     - Eviction 작업 건너뜀                                          │
│     - 경고 로그 기록                                                 │
│     - 다음 주기에 재시도                                             │
│                                                                     │
│  4. 별도 헬스 체크 API:                                              │
│     GET /health/cache                                               │
│     → { "status": "healthy" | "unhealthy", "details": {...} }       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 이벤트 (EventEmitter)

### 발행 이벤트

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Eviction 이벤트]                                                    │
│                                                                     │
│  1. eviction.started                                                 │
│     - 발생: Eviction 작업 시작 시                                    │
│     - 데이터: { spaceToFree, policy, timestamp }                     │
│                                                                     │
│  2. eviction.completed                                               │
│     - 발생: Eviction 작업 완료 시                                    │
│     - 데이터: { evictedCount, freedSpace, errors, duration }         │
│                                                                     │
│  3. cache.evicted                                                    │
│     - 발생: 개별 파일 제거 성공 시                                    │
│     - 데이터: { fileId, fileName, size, policy, timestamp }          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 이벤트 리스너 예시

```typescript
@OnEvent('eviction.completed')
async handleEvictionCompleted(payload: EvictionResult) {
  // 슬랙/이메일 알림
  if (payload.errors.length > 0) {
    await this.alertService.sendAlert({
      type: 'EVICTION_ERRORS',
      message: `Eviction 중 ${payload.errors.length}건 오류 발생`,
      details: payload.errors,
    });
  }
}

@OnEvent('cache.evicted')
async handleCacheEvicted(payload: CacheEvictedEvent) {
  // 로그 기록
  this.logger.log(`캐시 제거: ${payload.fileName} (${payload.size} bytes)`);
}
```

---

## 다운로드/미리보기 시 Lease 관리 및 접근 통계 업데이트

### Lease 메커니즘 개요

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Lease를 통한 읽기 중 삭제 방지]                                      │
│                                                                     │
│  목적: 파일 다운로드/미리보기 중 Eviction Worker가 해당 파일을 삭제   │
│        하지 못하도록 보호                                            │
│                                                                     │
│  [User Read]                                                         │
│    ├─ (1) lease +1 (atomic) ← 읽기 시작 전                           │
│    ├─ (2) stream from cache ← 실제 파일 스트리밍                     │
│    └─ (3) lease -1 (atomic) ← 읽기 완료/실패 (finally)               │
│                                                                     │
│  [Eviction Worker]                                                   │
│    ├─ (A) 후보 선택: 오래됨 + 큼 + NAS=SYNCED + lease=0              │
│    └─ (B) atomic mark: AVAILABLE & lease=0 → EVICTING               │
│           (조건 미충족 시 건너뜀)                                     │
│                                                                     │
│  ★ Atomic Mark의 중요성 ★                                            │
│  - lease=0 체크와 EVICTING 전환이 단일 atomic 연산                   │
│  - Race Condition 방지: 체크 시점과 삭제 시점 사이에 읽기 요청 불가   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [다운로드 시 Lease 관리 + 접근 통계 업데이트]                          │
│                                                                     │
│  1. 파일 다운로드 요청                                               │
│                                                                     │
│  2. 캐시 히트 (CACHE_SEAWEED에서 조회 성공):                          │
│     ┌─────────────────────────────────────────────────────────────┐ │
│     │ (1) ★Lease 획득★ (atomic)                                    │ │
│     │     UPDATE file_storage_objects                             │ │
│     │     SET leaseCount = leaseCount + 1                         │ │
│     │     WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'      │ │
│     │                                                             │ │
│     │ (2) 파일 스트리밍                                            │ │
│     │     try {                                                   │ │
│     │       await streamFileFromCache(fileId)                     │ │
│     │       // 접근 통계 업데이트                                  │ │
│     │       UPDATE lastAccessed = NOW(), accessCount += 1         │ │
│     │     }                                                       │ │
│     │                                                             │ │
│     │ (3) ★Lease 해제★ (finally - 성공/실패 무관)                  │ │
│     │     finally {                                               │ │
│     │       UPDATE file_storage_objects                           │ │
│     │       SET leaseCount = GREATEST(leaseCount - 1, 0)          │ │
│     │       WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'    │ │
│     │     }                                                       │ │
│     └─────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  3. 캐시 미스 (NAS에서 복원):                                         │
│     ┌─────────────────────────────────────────────────────────────┐ │
│     │ (1) NAS에서 캐시로 복원 + Lease=1로 INSERT                   │ │
│     │     INSERT file_storage_objects (                           │ │
│     │       fileId, storageType='CACHE_SEAWEED',                  │ │
│     │       objectKey=fileId, availabilityStatus='AVAILABLE',     │ │
│     │       lastAccessed = NOW(),                                 │ │
│     │       accessCount = 1,                                      │ │
│     │       leaseCount = 1  ← 복원 직후 읽기 중이므로              │ │
│     │     )                                                       │ │
│     │                                                             │ │
│     │ (2) 파일 스트리밍 (try)                                      │ │
│     │                                                             │ │
│     │ (3) ★Lease 해제★ (finally)                                   │ │
│     │     SET leaseCount = GREATEST(leaseCount - 1, 0)            │ │
│     └─────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  4. 파일 스트림 응답                                                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Lease와 Eviction의 상호작용

```
┌─────────────────────────────────────────────────────────────────────┐
│  [시나리오: 동시 읽기와 Eviction]                                     │
│                                                                     │
│  시간  │ User A (읽기)          │ Eviction Worker                   │
│  ──────┼────────────────────────┼──────────────────────────────────│
│  T1    │ lease +1 (→ lease=1)   │                                  │
│  T2    │ streaming...           │ 후보 선택 (file X, lease=1)      │
│  T3    │ streaming...           │ atomic mark 시도                 │
│  T4    │ streaming...           │ ❌ lease≠0 → 건너뜀              │
│  T5    │ streaming 완료         │                                  │
│  T6    │ lease -1 (→ lease=0)   │                                  │
│  T7    │                        │ (다음 주기에 재시도 가능)         │
│                                                                     │
│  ★ User A의 읽기 중에는 Eviction 불가 → 데이터 무결성 보장 ★        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────┐
│  [시나리오: Eviction 진행 중 읽기 요청]                               │
│                                                                     │
│  시간  │ Eviction Worker        │ User B (읽기)                     │
│  ──────┼────────────────────────┼──────────────────────────────────│
│  T1    │ atomic mark 성공       │                                  │
│        │ (AVAILABLE → EVICTING) │                                  │
│  T2    │ 캐시 삭제 중...        │ 읽기 요청                        │
│  T3    │ 캐시 삭제 중...        │ status=EVICTING 확인             │
│  T4    │ 캐시 삭제 중...        │ ⏳ NAS에서 직접 조회 또는 대기   │
│  T5    │ 삭제 완료              │                                  │
│  T6    │                        │ 캐시 미스 처리 (NAS → 캐시 복원) │
│                                                                     │
│  ★ EVICTING 상태 파일은 캐시에서 읽지 않음 → NAS 폴백 ★             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 모니터링 대시보드 항목

### 주요 메트릭

```
┌─────────────────────────────────────────────────────────────────────┐
│  [캐시 모니터링 메트릭]                                               │
│                                                                     │
│  1. 용량 관련                                                        │
│     - 현재 캐시 사용량 (bytes, %)                                    │
│     - 최대 캐시 용량                                                 │
│     - 캐시 파일 수                                                   │
│                                                                     │
│  2. Eviction 관련                                                    │
│     - 마지막 Eviction 시간                                          │
│     - 마지막 Eviction 결과 (제거 파일 수, 확보 공간)                  │
│     - Eviction 에러 수                                               │
│                                                                     │
│  3. 성능 관련                                                        │
│     - 캐시 히트율 (Cache Hit Ratio)                                  │
│     - 평균 접근 횟수 (accessCount)                                   │
│     - 평균 캐시 체류 시간                                            │
│                                                                     │
│  4. 헬스 관련                                                        │
│     - 캐시 서버 상태                                                 │
│     - 마지막 헬스 체크 시간                                          │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 알림 조건

| 조건 | 알림 레벨 | 메시지 |
|------|----------|--------|
| usagePercent > 90% | WARNING | 캐시 사용량 90% 초과 |
| usagePercent > 95% | CRITICAL | 캐시 사용량 위험 수준 |
| 캐시 서버 비정상 | ERROR | 캐시 서버 연결 실패 |
| Eviction 에러 > 10건 | WARNING | Eviction 오류 다수 발생 |

---

## 설정 예시 (.env)

```bash
# ===== 캐시 설정 =====

# 캐시 최대 용량 (bytes) - 기본값: 10GB
CACHE_MAX_SIZE_BYTES=10737418240

# Eviction 임계값 (%) - 이 비율 초과 시 eviction 시작
CACHE_THRESHOLD_PERCENT=80

# Eviction 목표 사용률 (%) - eviction 후 도달할 목표
CACHE_TARGET_PERCENT=70

# Eviction 배치 크기 - 한 번에 처리할 파일 수
CACHE_EVICTION_BATCH_SIZE=100

# 기본 Eviction 정책 (LRU | LFU | FIFO)
CACHE_EVICTION_POLICY=LRU
```

---

## 트러블슈팅

### 1. Eviction이 실행되지 않는 경우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [체크리스트]                                                         │
│                                                                     │
│  □ 캐시 서버(SeaweedFS) 연결 상태 확인                               │
│  □ cache_settings 테이블에 설정 존재 여부                            │
│  □ 현재 사용량이 임계값 미만인지 확인                                 │
│  □ EvictionWorker 로그 확인                                          │
│  □ 이전 Eviction 작업이 아직 진행 중인지 확인                         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2. Eviction 후에도 용량이 줄지 않는 경우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [원인 및 해결]                                                       │
│                                                                     │
│  원인 1: NAS에 동기화되지 않은 파일이 대부분                          │
│  → NAS 동기화 상태 확인 후 동기화 완료 대기                           │
│                                                                     │
│  원인 2: SeaweedFS 삭제 실패                                          │
│  → SeaweedFS 로그 확인, 연결 상태 점검                                │
│                                                                     │
│  원인 3: DB와 실제 캐시 불일치                                        │
│  → 캐시 일관성 검증 배치 실행                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3. DB 롤백 실패 시 대응

```
┌─────────────────────────────────────────────────────────────────────┐
│  [심각: DB 롤백 실패]                                                 │
│                                                                     │
│  증상: DB는 evicted 상태인데 실제 캐시 파일이 존재                    │
│                                                                     │
│  대응:                                                               │
│  1. 관리자 알림 확인                                                 │
│  2. 해당 파일 수동 확인                                              │
│  3. 필요 시 수동으로 DB 상태 복원 또는 캐시 파일 삭제                 │
│  4. 원인 분석 및 재발 방지                                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 요약

| 구성 요소 | 역할 | 참조 |
|----------|------|------|
| **EvictionWorker** | 주기적 캐시 제거 실행 | `eviction.worker.ts` |
| **EvictionPolicyService** | 정책 기반 제거 대상 조회 | `eviction-policy.service.ts` |
| **cache_settings** | 캐시 설정 저장 | DB 테이블 |
| **file_storage_objects** | 파일별 접근 통계 | `lastAccessed`, `accessCount` |

**핵심 포인트:**
1. **2-tier 아키텍처**: SeaweedFS(캐시) + NAS(영구)
2. **정책 기반 Eviction**: LRU / LFU / FIFO 지원
3. **안전한 제거**: DB 먼저 업데이트, 실패 시 롤백
4. **NAS 동기화 보장**: 동기화되지 않은 파일은 제거 불가
5. **접근 통계 기반**: 다운로드/미리보기 시 통계 업데이트
6. **Lease 메커니즘**: 읽기 중인 파일 보호 (leaseCount > 0 시 Eviction 제외)
7. **Atomic Mark**: lease=0 체크 + EVICTING 전환을 단일 연산으로 수행