## *공통 사항*

##### 1.로깅 (Trace + Span 구조)

해당 작업마다의 요청 트랜젝션 ID(요청시간, 요청자, 요청 내용)를 생성 해서 진행과정 전부 로그 처리 
(개발기간 동안 모든 구간 로그 처리 남기기, 운영레벨에서는 어느정도 할지 개발하면서 정함)


##### 2.SeaweedFS 의사 트랜잭션 처리 원칙

*SeaweedFS는 외부 시스템이므로 DB 트랜잭션에 직접 포함 불가 → 순서 조정 + 보상 로직으로 일관성 유지*

**핵심 원칙: 작업 유형에 따라 순서가 다름**

```
┌────────────────────────────────────────────────────────────────────────────┐
│                                                                            │
│  [업로드/생성] SeaweedFS 먼저 → DB 나중                                     │
│  ────────────────────────────────────────                                  │
│  이유: SeaweedFS 실패 시 DB 변경 없음 (롤백 불필요, 깔끔한 실패)             │
│  보상: DB 실패 시 SeaweedFS 삭제                                           │
│                                                                            │
│  0. UUID 미리 생성 (fileId)                                                │
│  1. SeaweedFS 저장 (objectKey = fileId)  ← 먼저!                           │
│     └─ 실패 시: 즉시 에러 반환                                             │
│  2. DB 트랜잭션 (INSERT files, INSERT file_storage_objects, ...)           │
│     └─ 실패 시: SeaweedFS 삭제 (보상)                                      │
│  3. 커밋 완료                                                              │
│                                                                            │
├────────────────────────────────────────────────────────────────────────────┤
│                                                                            │
│  [삭제/영구삭제] DB 먼저 → SeaweedFS 나중                                   │
│  ────────────────────────────────────────                                  │
│  이유: DB에서 DELETED = 사용자에게 삭제된 것, 물리 삭제는 후처리            │
│  보상: SeaweedFS 삭제 실패 → 배치로 정리 (DB 롤백 안 함)                    │
│                                                                            │
│  1. DB 트랜잭션 (UPDATE state=DELETED, UPDATE availabilityStatus=PENDING)  │
│     └─ 실패 시: 롤백 (SeaweedFS 변경 없음)  ← 먼저!                         │
│  2. SeaweedFS 삭제 시도                                                    │
│     └─ 실패 시: DB 롤백 안 함, 배치 정리 대상으로 기록                      │
│  3. 커밋 완료                                                              │
│                                                                            │
└────────────────────────────────────────────────────────────────────────────┘
```

<!-- **고아 파일 정리 배치 (SeaweedFS Orphan Cleanup)**

*SeaweedFS 보상 삭제 실패 또는 삭제 요청 실패 시 발생하는 고아 파일 정리*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [배치 워커: @Cron('0 */6 * * *') - 6시간마다]                       │
│                                                                     │
│  1. 업로드 실패 고아 파일 정리                                       │
│     - SeaweedFS에 존재하지만 DB에 없는 파일 검색                     │
│     - 생성 후 1시간 이상 경과한 파일 삭제                            │
│                                                                     │
│  2. 삭제 실패 고아 파일 정리                                         │
│     - file_storage_objects WHERE availabilityStatus=PENDING         │
│       AND updatedAt < NOW() - INTERVAL 1 HOUR                       │
│     - SeaweedFS 삭제 재시도 → 성공 시 레코드 삭제                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
``` -->

---

##### 3.동시성 제어 (NAS 동기화 중 수정 방지 + Race Condition 방지)

*문제 상황 1: Bull에서 NAS 동기화 처리 중 사용자가 파일 수정 요청 시 불일치 발생*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [문제 시나리오 1 - NAS 동기화 중 수정]                               │
│                                                                     │
│  1. 파일 업로드 완료 → Bull에 NAS_SYNC_UPLOAD 등록                   │
│  2. Bull Worker가 NAS 업로드 처리 중... (시간 소요)                  │
│  3. 사용자가 파일 이름 변경 요청!                                    │
│  4. DB에서 name 변경 + Bull에 NAS_SYNC_RENAME 등록                   │
│  5. 결과:                                                           │
│     - Bull Worker 1: 이전 이름으로 NAS 저장 시도 → ???               │
│     - Bull Worker 2: 새 이름으로 변경 시도 → 파일 없음!              │
│     - 불일치 발생!                                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

*문제 상황 2: 동시 API 요청으로 인한 Race Condition*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [문제 시나리오 2 - Race Condition]                                  │
│                                                                     │
│  시간  │ 요청 A (파일 업로드)      │ 요청 B (파일 이름 변경)         │
│  ──────┼──────────────────────────┼────────────────────────────────│
│  T1    │ SeaweedFS 저장 시작       │                                │
│  T2    │ SeaweedFS 저장 중...      │ files SELECT (파일 없음)       │
│  T3    │ SeaweedFS 저장 완료       │ 404 반환? or 진행?             │
│  T4    │ BEGIN TRANSACTION        │                                │
│  T5    │ INSERT files             │ BEGIN TRANSACTION              │
│  T6    │                          │ SELECT files FOR UPDATE ← 대기 │
│  T7    │ COMMIT                   │                                │
│  T8    │                          │ 락 획득 → 파일 존재 확인       │
│  T9    │                          │ 정상 처리 가능                  │
│                                                                     │
│  ※ FOR UPDATE 없이는 T2~T3 시점에 요청 B가 "파일 없음" 처리하거나,  │
│     T5~T6에서 동시에 같은 파일에 대해 작업하여 데이터 불일치 발생!   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

**해결 방법 1: SELECT ... FOR UPDATE (비관적 락)**

*파일/폴더 수정/삭제/이동 시 대상 레코드를 먼저 락하여 Race Condition 방지*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [FOR UPDATE 사용 이유]                                              │
│                                                                     │
│  1. 동시 요청 직렬화                                                 │
│     - 같은 파일에 대한 여러 수정 요청이 동시에 들어와도              │
│     - 락을 획득한 트랜잭션만 처리, 나머지는 대기                     │
│                                                                     │
│  2. 업로드 완료 대기                                                 │
│     - 업로드 트랜잭션이 files INSERT 후 커밋할 때까지               │
│     - 수정 요청은 락 대기 → 커밋 후 락 획득 → 파일 존재 확인        │
│                                                                     │
│  3. 일관성 보장                                                      │
│     - 조회 시점과 수정 시점 사이에 다른 트랜잭션이 끼어들지 못함     │
│     - "읽은 값 = 수정할 값" 보장                                    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

```sql
-- 파일 수정/삭제/이동 시작 전에 files 레코드를 락
SELECT * FROM files WHERE id = ? FOR UPDATE;

-- files 레코드가 존재하면 락이 걸림
-- 다른 트랜잭션은 이 트랜잭션이 커밋/롤백될 때까지 대기
-- 업로드 트랜잭션이 files INSERT 후 커밋할 때까지 대기
```

```
┌─────────────────────────────────────────────────────────────────────┐
│  [FOR UPDATE 적용 대상]                                              │
│                                                                     │
│  ✅ 파일 작업                                                        │
│     - 파일명 변경 (RENAME)                                          │
│     - 파일 이동 (MOVE)                                              │
│     - 파일 삭제 (DELETE/TRASH)                                      │
│                                                                     │
│  ✅ 폴더 작업                                                        │
│     - 폴더명 변경 (RENAME)                                          │
│     - 폴더 이동 (MOVE)                                              │
│     - 폴더 삭제 (DELETE/TRASH)                                      │
│                                                                     │
│  ❌ 제외 (락 불필요)                                                 │
│     - 조회 (READ) - 락 없이 조회                                    │
│     - 생성 (CREATE) - 새 레코드이므로 충돌 없음                     │
│     - 다운로드 (DOWNLOAD) - 읽기 전용                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

**해결 방법 2: file_storage_objects.availabilityStatus 기반 동시성 제어**

---

**해결 방법: file_storage_objects.availabilityStatus 기반 동시성 제어**

*별도 syncStatus 컬럼 없이 file_storage_objects의 NAS 레코드 상태로 판단*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [동기화 상태 판단 로직]                                              │
│                                                                     │
│  file_storage_objects에서 storageType=NAS 레코드 조회:               │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ NAS 레코드 없음           → 동기화 전 (수정 가능)               ││
│  │ NAS 레코드 + SYNCING      → 동기화 중 (수정 차단)               ││
│  │ NAS 레코드 + AVAILABLE    → 동기화 완료 (수정 가능)             ││
│  │ NAS 레코드 + ERROR        → 동기화 실패 (수동 처리 필요)        ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────────┐
│  [file_storage_objects NAS 레코드 상태 전이]                          │
│                                                                     │
│  ┌──────────┐   Bull 등록   ┌──────────┐   처리 완료   ┌───────────┐│
│  │ (없음)   │ ───────────→ │ SYNCING  │ ───────────→ │ AVAILABLE ││
│  │ 수정가능 │               │ 수정차단 │               │ 수정가능  ││
│  └──────────┘               └──────────┘               └───────────┘│
│       ↑                          │                          │       │
│       │                          │ 최종 실패                │       │
│       │                          ↓                          │       │
│       │    수동 처리 후    ┌──────────┐     재수정 시       │       │
│       └─────────────────── │  ERROR   │ ←───────────────────┘       │
│                            │ 수동처리 │                             │
│                            └──────────┘                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

| NAS 레코드 상태 | 설명 | 사용자 작업 |
|----------------|------|------------|
| 레코드 없음 | NAS 동기화 전 (업로드 직후) | ✅ 수정 가능 (새 작업으로 대체) |
| SYNCING | Bull 처리 중 | ❌ 수정 차단 (409 Conflict) |
| AVAILABLE | NAS 동기화 완료 | ✅ 수정 가능 |
| ERROR | 최종 실패 | ⚠️ 수동 처리 필요 (관리자 확인) |

---

**파일 수정/삭제/변경 시 동시성 체크 플로우**

```
┌─────────────────────────────────────────────────────────────────────┐
│  [파일 수정 요청 시 체크 플로우]                                      │
│                                                                     │
│  1. 사용자 → API: 파일 수정 요청 (이름변경/이동/삭제)                 │
│                                                                     │
│  2. === BEGIN TRANSACTION ===                                       │
│                                                                     │
│  3. ★files 테이블 락 획득★ (Race Condition 방지)                    │
│     SELECT * FROM files WHERE id = ? FOR UPDATE;                    │
│     -- 다른 트랜잭션(업로드/수정/삭제)이 완료될 때까지 대기          │
│     -- 업로드 트랜잭션이 커밋될 때까지 대기                         │
│     -- 파일이 없으면 404 반환                                       │
│                                                                     │
│  4. API → DB: file_storage_objects 조회                             │
│     SELECT * FROM file_storage_objects                              │
│     WHERE fileId = ? AND storageType = 'NAS'                        │
│     FOR UPDATE (비관적 락)                                          │
│                                                                     │
│  5. NAS 레코드 상태 체크:                                            │
│     ┌─────────────────────────────────────────────────────────────┐ │
│     │ 레코드 없음     → 수정 진행 (동기화 전, 새 작업으로 대체)    │ │
│     │ AVAILABLE      → 수정 진행 허용                             │ │
│     │ SYNCING        → 409 Conflict 반환                          │ │
│     │                  "NAS 동기화 중입니다. 잠시 후 재시도"       │ │
│     │ ERROR          → 경고 로그 + 수정 진행 (새 동기화로 대체)    │ │
│     └─────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  6. 수정 진행 시 (동일 트랜잭션 내):                                 │
│     - files 테이블 수정                                             │
│     - file_storage_objects (NAS) 레코드:                            │
│       · 레코드 없음 → INSERT (availabilityStatus = SYNCING)        │
│       · 레코드 있음 → UPDATE availabilityStatus = SYNCING          │
│                                                                     │
│  7. === COMMIT ===                                                  │
│                                                                     │
│  8. 트랜잭션 커밋 후 → Bull 큐 등록                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

**Bull Worker 처리 플로우 (file_storage_objects 기반)**

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Bull Worker - NAS 동기화 처리 (최대 3회 재시도)]                    │
│                                                                     │
│  1. Bull 큐에서 작업 수신 (fileId, eventType)                        │
│                                                                     │
│  2. NAS 작업 수행 (업로드/이름변경/이동/삭제)                         │
│                                                                     │
│  3. 결과 처리:                                                       │
│     ┌─────────────────────────────────────────────────────────────┐ │
│     │ 성공 시:                                                     │ │
│     │   → UPDATE file_storage_objects                             │ │
│     │     SET availabilityStatus = 'AVAILABLE',                   │ │
│     │         objectKey = 실제NAS경로                              │ │
│     │     WHERE fileId = ? AND storageType = 'NAS'                │ │
│     ├─────────────────────────────────────────────────────────────┤ │
│     │ 실패 시 (재시도 가능, 1~2회차):                               │ │
│     │   → Bull 자동 재시도 (지수 백오프)                           │ │
│     │   → availabilityStatus = SYNCING 유지                       │ │
│     ├─────────────────────────────────────────────────────────────┤ │
│     │ 최종 실패 시 (3회 재시도 소진):                               │ │
│     │   → file_storage_objects.availabilityStatus = ERROR         │ │
│     │   → 관리자 알림 발송 (Alert)                                 │ │
│     │   → 로그 기록 (실패 원인, fileId, 시도 횟수)                  │ │
│     └─────────────────────────────────────────────────────────────┘ │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

**폴더 동시성 제어 (folder_storage_objects 기반)**

*파일과 동일하게 folder_storage_objects.availabilityStatus로 동기화 상태 판단*

```
┌─────────────────────────────────────────────────────────────────────┐
│  [폴더 수정 요청 시 체크 플로우]                                      │
│                                                                     │
│  1. 사용자 → API: 폴더 수정 요청 (이름변경/이동/삭제)                 │
│                                                                     │
│  2. === BEGIN TRANSACTION ===                                       │
│                                                                     │
│  3. ★folders 테이블 락 획득★ (Race Condition 방지)                  │
│     SELECT * FROM folders WHERE id = ? FOR UPDATE;                  │
│     -- 다른 트랜잭션(생성/수정/삭제)이 완료될 때까지 대기            │
│     -- 폴더 생성 트랜잭션이 커밋될 때까지 대기                       │
│     -- 폴더가 없으면 404 반환                                       │
│                                                                     │
│  4. API → DB: folder_storage_objects 조회                           │
│     SELECT * FROM folder_storage_objects                            │
│     WHERE folderId = ? AND storageType = 'NAS'                      │
│     FOR UPDATE (비관적 락)                                          │
│                                                                     │
│  5. NAS 레코드 상태 체크:                                            │
│     ┌─────────────────────────────────────────────────────────────┐ │
│     │ 레코드 없음     → 수정 진행 (동기화 전, 새 작업으로 대체)    │ │
│     │ AVAILABLE      → 수정 진행 허용                             │ │
│     │ SYNCING        → 409 Conflict 반환                          │ │
│     │                  "폴더 동기화 중입니다. 잠시 후 재시도"      │ │
│     │ ERROR          → 경고 로그 + 수정 진행 (새 동기화로 대체)    │ │
│     └─────────────────────────────────────────────────────────────┘ │
│                                                                     │
│  6. 수정 진행 시 (동일 트랜잭션 내):                                 │
│     - folders 테이블 수정                                           │
│     - folder_storage_objects (NAS) 레코드:                          │
│       · 레코드 없음 → INSERT (availabilityStatus = SYNCING)        │
│       · 레코드 있음 → UPDATE availabilityStatus = SYNCING          │
│                                                                     │
│  7. === COMMIT ===                                                  │
│                                                                     │
│  8. 트랜잭션 커밋 후 → Bull 즉시 처리 (1회만)                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

| NAS 레코드 상태 | 설명 | 사용자 작업 |
|----------------|------|------------|
| 레코드 없음 | NAS 동기화 전 | ✅ 수정 가능 (새 작업으로 대체) |
| SYNCING | Bull 처리 중 | ❌ 수정 차단 (409 Conflict) |
| AVAILABLE | NAS 동기화 완료 | ✅ 수정 가능 |
| ERROR | 최종 실패 | ⚠️ 수동 처리 필요 (관리자 확인) |

---

**프론트엔드 UX 처리**

```
┌─────────────────────────────────────────────────────────────────────┐
│  [API 응답에 storageStatus 포함 (file_storage_objects에서 계산)]      │
│                                                                     │
│  GET /files/{fileId} 응답:                                          │
│  {                                                                  │
│    "id": "file-uuid",                                               │
│    "name": "document.pdf",                                          │
│    "storageStatus": {                                               │
│      "cache": "AVAILABLE",      ← file_storage_objects 캐시 상태   │
│      "nas": "SYNCING"           ← file_storage_objects NAS 상태    │
│    },                                                               │
│    "nasSyncMessage": "NAS 동기화 중..."                             │
│  }                                                                  │
│                                                                     │
│  프론트엔드 처리:                                                    │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ nas = null/AVAILABLE  → 수정 버튼 활성화                     │    │
│  │ nas = SYNCING         → 수정 버튼 비활성화 + "동기화 중"     │    │
│  │ nas = ERROR           → 경고 아이콘 + "동기화 실패" 표시     │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---



##### 4. 공통 

---

**NAS 동기화 아키텍처 (Bull Queue 기반)**

*설계 원칙*
- **Bull Queue**: 트랜잭션 커밋 후 Bull 큐에 등록, 최대 3회 재시도
- **최종 실패 시 Alert**: 3회 실패 시 관리자 알림 + ERROR 상태 기록
```
┌─────────────────────────────────────────────────────────────────────┐
│  [핵심 설계]                                                         │
│                                                                     │
│  방식: DB 트랜잭션 커밋 → Bull 큐 등록 → 최대 3회 재시도             │
│                                                                     │
│  장점:                                                              │
│  - 즉시 비동기 처리 (빠른 응답)                                     │
│  - 지수 백오프 재시도 (안정적)                                      │
│  - 최종 실패 시 명확한 ERROR 상태 + Alert                           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---


**전체 처리 흐름**

```
┌─────────────────────────────────────────────────────────────────────┐
│  [STEP 1] DB 트랜잭션 (ACID 보장)                                    │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │ === BEGIN TRANSACTION ===                                     │ │
│  │ 1. files/folders 생성/수정/삭제                               │ │
│  │ 2. file_storage_objects 상태 업데이트 (NAS: SYNCING)          │ │
│  │ === COMMIT ===                                                │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                   ↓ 트랜잭션 커밋 후
┌─────────────────────────────────────────────────────────────────────┐
│  [STEP 2] Bull 큐 등록 (최대 3회 재시도)                             │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │ await nasQueue.add('sync', {                                  │ │
│  │   syncEventId: syncEvent.id,                                  │ │
│  │   traceId, aggregateType, aggregateId, eventType, payload     │ │
│  │ }, {                                                          │ │
│  │   attempts: 3,              ← 최대 3회 재시도                  │ │
│  │   backoff: {                                                  │ │
│  │     type: 'exponential',                                      │ │
│  │     delay: 5000             ← 5초, 10초, 20초 간격             │ │
│  │   },                                                          │ │
│  │   removeOnComplete: true,                                     │ │
│  │   removeOnFail: false       ← 실패 기록 유지 (분석용)          │ │
│  │ });                                                           │ │
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
                                   ↓
┌─────────────────────────────────────────────────────────────────────┐
│  [STEP 3] Bull Worker - NAS 동기화 처리                              │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │ @Process('sync')                                              │ │
│  │ async handleSync(job) {                                       │ │
│  │   const { syncEventId, aggregateId, eventType } = job.data;   │ │
│  │                                                               │ │
│  │   try {                                                       │ │
│  │     // NAS 작업 수행                                          │ │
│  │     await nasService.upload/rename/move/delete(...)           │ │
│  │                                                               │ │
│  │     // 성공 → 상태 업데이트                                   │ │
│  │     await syncEventRepository.update(syncEventId, {           │ │
│  │       status: 'DONE', processedAt: new Date()                 │ │
│  │     });                                                       │ │
│  │     await updateStorageObjectStatus(AVAILABLE);               │ │
│  │                                                               │ │
│  │   } catch (error) {                                           │ │
│  │     // Bull이 자동으로 재시도 (최대 3회)                       │ │
│  │     throw error;                                              │ │
│  │   }                                                           │ │
│  │ }                                                             │ │
│  │                                                               │ │
│  │ @OnQueueFailed()                                              │ │     
      050. 큐관리.MD 파일 확인                                             
│  └───────────────────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────────────────────┘
```

---
```
┌─────────────────────────────────────────────────────────────────────┐
│  [file_storage_objects.availabilityStatus 상태 전이]                 │
│                                                                     │
│  ┌──────────┐   Bull 등록   ┌──────────┐   성공   ┌───────────┐     │
│  │ (없음)   │ ───────────→ │ SYNCING  │ ───────→ │ AVAILABLE │     │
│  │ 수정가능 │               │ 수정차단 │          │ 수정가능  │     │
│  └──────────┘               └────┬─────┘          └───────────┘     │
│                                  │                                  │
│                                  │ Bull 3회 실패                    │
│                                  ↓                                  │
│                             ┌──────────┐                            │
│                             │  ERROR   │ ← Alert 발송됨             │
│                             │ 수동처리 
│                            │050.큐관리.md 파일확인|
│                             └──────────┘                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

**Trace/Span 흐름**

```
[API 요청 - traceId: api-xxx]
├─ SPAN: db.transaction
│   ├─ db.file_create/update
│   ├─ db.storage_object_update
│   ├─ db.file_event_insert
│   └─ db.sync_event_insert    ← 작업 로그
├─ SPAN: redis.queue_add (Bull 등록)
└─ SPAN: api.response

[Bull Worker - 동일 traceId 사용]
├─ SPAN: nas.upload/rename/move/delete
├─ (성공 시) SPAN: db.sync_event_done + db.storage_available
└─ (최종 실패 시) SPAN: db.sync_event_failed + db.storage_error + alert.send
```

---

**장점**
- **빠른 응답**: Bull로 즉시 비동기 처리
- **안정적 재시도**: Bull 지수 백오프로 3회 재시도
- **명확한 실패 처리**: 3회 실패 시 ERROR 상태 + 관리자 Alert
- **추적성**: traceId로 전체 흐름 연결 가능
- **단순한 구조**: Polling 없이 Bull만 사용

---

**Bull 재시도 간격 (지수 백오프)**

| retryCount | availableAt (대기 시간) |
|------------|------------------------|
| 1 | NOW() + 1분 |
| 2 | NOW() + 3분 |
| 3 | NOW() + 6분 |
| 5 | DEAD (최종 실패) |

---

*SeaweedFS(캐시) 처리 방식*
- SeaweedFS 저장은 외부 I/O이므로 트랜잭션에 포함 불가
- file_storage_objects.availabilityStatus(파일)로 상태 관리:
- folder_storage_objects.availabilityStatus(폴더)로 상태 관리:
  - SYNCING: NAS 동기화 대기/진행 중
  - AVAILABLE: 정상 저장됨
  - ERROR: 저장 실패 (수동 처리 필요)
  - MISSING: 파일 없음 (복원 필요)
- 캐시 저장 실패 시 보상 로직으로 처리 (재시도 또는 롤백)

---

### *메인 작업 플로우 정의*

#### ㄱ.파일 ===============================


##### 1.파일 업로드

공통 

1)동일 파일명 존재 확인
  -해당 폴더 레벨에 같은  mimeType  && name 이 있는지 조회 
  1-1) 존재한다면 동일 파일명 존재 다른 이름 으로 변경 해주세요 에러메시지 리턴'
  1-2) 존재하지 않는다면 그대로 진행


###### 1-A. 일반 업로드 (500MB 미만)

**핵심 설계: UUID 미리 생성 + SeaweedFS 우선 저장 + Bull 비동기 처리**

```
┌─────────────────────────────────────────────────────────────────────┐
│  [업로드 시나리오 - 의사 트랜잭션 + Bull 비동기 처리]                  │
│                                                                     │
│  0. UUID 미리 생성: fileId = uuid.v4()                              │
│                                                                     │
│  1. SeaweedFS 저장 (objectKey = fileId 사용)                         │
│     ↓ 실패 시 → 즉시 에러 반환 (DB 변경 없음, 롤백 불필요)           │
│     ↓ 성공 시                                                       │
│                                                                     │
│  2. DB 트랜잭션 시작                                                 │
│     - INSERT files (id = fileId)                                    │
│     - INSERT file_storage_objects (CACHE + NAS:SYNCING)             │
│     ↓ 실패 시 → DB 롤백 + SeaweedFS 삭제 (보상)                      │
│     ↓ 성공 시                                                       │
│                                                                     │
│  3. 커밋 완료 → Bull 즉시 처리 (1회만)                               │
│     ↓ 실패 시 Bull 자동 재시도 (최대 3회, 최종 실패 시 Alert)         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**플로우 상세**

1)유저(파일저장해줘)===> 


3-1)프론트 처리: 500MB 미만의 경우 일반 업로드로 요청

4-1)폴더 검증 (존재하지 않는 폴더라면 폴더생성 먼저 요청) 

4-2)동일 파일명 존재 확인
  -해당 폴더 레벨에 같은  mimeType  && name 이 있는지 조회 
  2-1) 존재한다면 동일 파일명 존재 다른 이름 으로 변경 해주세요 에러메시지 리턴'
  2-2) 존재하지 않는다면 그대로 진행


5)★UUID 미리 생성★ 
```
const fileId = uuid.v4();  // DB INSERT 전에 미리 생성!
```

6)★SeaweedFS 저장 먼저★ (objectKey = fileId) 
```
await seaweedService.upload(fileId, fileBuffer, mimeType);
// 실패 시 → 즉시 에러 반환 (DB 변경 없음, 롤백 불필요)
```

7)★DB 트랜잭션★ 
```
=== BEGIN TRANSACTION ===
1. INSERT files (
     id = fileId,  ← 미리 생성한 UUID 사용!
     state=ACTIVE
   ) 

2. INSERT file_storage_objects (캐시용)
   (fileId, storageType=CACHE_SEAWEED, objectKey=fileId, 
    availabilityStatus=AVAILABLE,
    lastAccessed=NOW(), accessCount=1)  ← 업로드 시점 = 첫 접근

3. INSERT file_storage_objects (NAS용 - SYNCING 상태)
   (fileId, storageType=NAS, objectKey=예상NAS경로, 
    availabilityStatus=SYNCING) ← 동시성 제어용
  

=== COMMIT ===
```

6)★DB 실패 시 보상 로직★ 
```
// DB 트랜잭션 실패 시 SeaweedFS에서 파일 삭제 (보상)
await seaweedService.delete(fileId).catch(e => {
  logger.error(`보상 삭제 실패: ${fileId}`, e);
});
```

7)트랜잭션 커밋 후 Bull 즉시 처리 (3회) 
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,  ← 작업 로그 ID 전달
  traceId, aggregateType: 'FILE', aggregateId: fileId,
  eventType: 'NAS_SYNC_UPLOAD',
  payload: { nasPath, fileName, mimeType, size }
}, { 
  attempts: 1,           ← 3회 시도!
  removeOnComplete: true,
  removeOnFail: false    ← 실패 기록 유지 (분석용)
});
```

8)Bull Worker  NAS 동기화 처리
8-1)성공 시:
    - UPDATE file_storage_objects SET availabilityStatus='AVAILABLE' (NAS)
8-2)실패 시:
    - 관리자 계정 알림 처리
    - 최종 실패 시 file_storage_objects  status='DEAD', availabilityStatus='ERROR'

*주의*
- **SeaweedFS 먼저 저장**: 외부 I/O 실패 시 DB 롤백 불필요
- **UUID 미리 생성**: SeaweedFS objectKey = files.id 일관성 유지
- **Bull 3회 재시도**: 최종 실패 시 Alert + ERROR 상태
- **NAS용 file_storage_objects**: SYNCING 상태로 미리 생성 (동시성 제어)


---

###### 1-B. 멀티파트 업로드 (500MB 이상)

**핵심 포인트: 완료 시점에만 files 생성 → 고아 데이터 방지**

**Trace/Span 흐름 (Phase별 별도 traceId)**
```
[Phase 1 - traceId: init-xxx]
├─ SPAN: api.request_validate
├─ SPAN: db.folder_validate
├─ SPAN: db.session_create
└─ SPAN: seaweed.initiate_multipart

[Phase 2 - 각 파트별 traceId: part-xxx-N]
├─ SPAN: seaweed.upload_part
└─ SPAN: db.upload_part_create

[Phase 3 - traceId: complete-xxx]
├─ SPAN: api.request_validate
├─ SPAN: seaweed.complete_multipart
├─ SPAN: db.transaction
│   ├─ db.file_create
│   ├─ db.storage_object_create
│   ├─ db.session_update
│   └─ db.file_event_insert
├─ SPAN: redis.queue_add
└─ SPAN: api.response
```

```
[Phase 1] 세션 초기화 → traceId 생성
    Client → API: POST /multipart/initiate
    API → DB: INSERT upload_sessions (status=INIT, traceId=init-xxx)
    API → Client: sessionId, uploadId 반환

[Phase 2] 파트 업로드 (반복) → 각 파트별 traceId 또는 sessionId로 그룹핑
    Client → Cache(SeaweedFS): PUT part (presigned URL) 
    Cache → Client: etag 반환
    Client → API: 파트 완료 알림
    API → DB: INSERT upload_parts (sessionId, partNumber, etag) 

[Phase 3] 완료 처리 (★단일 트랜잭션★) → 새 traceId 생성
    Client → API: POST /multipart/complete
    
    === BEGIN TRANSACTION === 
    1. INSERT files (state=ACTIVE) 
    2. INSERT file_storage_objects (...) 
    3. UPDATE upload_sessions (status=COMPLETED) 
    === COMMIT ===
    
    [트랜잭션 커밋 후]
    await nasQueue.add('sync', {...}) 
    
    API → Client: fileId 반환
```

*플로우 상세*
 0)유저(대용량 파일 저장해줘)===>
  0-1)프론트 처리: 500MB 이상의 경우 멀티파트 업로드로 요청

1-1)폴더 검증 (존재하지 않는 폴더라면 폴더생성 먼저 요청) 


1-2)동일 파일명 존재 확인
  -해당 폴더 레벨에 같은  mimeType  && name 이 있는지 조회 
  2-1) 존재한다면 동일 파일명 존재 다른 이름 으로 변경 해주세요 에러메시지 리턴'
  2-2) 존재하지 않는다면 그대로 진행


2)upload_sessions 생성 (status=INIT)
  2-1)uploadId 발급 및 presigned URL 안내
3)파트별 업로드 진행
  3-1)각 파트 완료 시 upload_parts에 기록 (etag/checksum 저장)
  3-2)이어받기(Resume) 지원: localStorage에 sessionId 저장
4)모든 파트 업로드 완료 후 complete 요청
5)★완료 시점에 단일 트랜잭션으로 처리★
  5-1)files 생성 (이 시점에만 논리 파일 메타 생성!)
  5-1-1) contentType,fileSize  값을  complete 시점에 캐시 파일 저장소 메타데이터로 확정
  5-2)file_storage_objects 생성 (storageType=CACHE_SEAWEED, availabilityStatus=AVAILABLE, lastAccessed=NOW(), accessCount=1)
  5-3)upload_sessions 상태 업데이트 (status=COMPLETED)
6)트랜잭션 커밋 후 Redis Queue (Bull) 등록 → NAS 동기화

*주의*
- 5-1~5-4는 반드시 하나의 트랜잭션으로 묶어야 함
- 업로드 실패/중단 시 files가 생성되지 않아 고아 데이터 방지
- NAS 동기화: Bull 큐 (3회 재시도, 최종 실패 시 Alert + ERROR)
- NAS 동기화 완료 시 file_storage_objects에 NAS 레코드 추가 (storageType=NAS)
- 만료된 세션(expiresAt 초과)은 배치로 정리

---

###### 1-B-1. 멀티파트 업로드 이어서 하기 (Resume)

**시나리오**: 네트워크 끊김, 브라우저 새로고침 등으로 업로드가 중단된 경우

**Trace/Span 흐름**
```
[Resume - traceId: resume-xxx]
├─ SPAN: api.request_validate
├─ SPAN: db.session_lookup         -- 기존 세션 조회
├─ SPAN: db.uploaded_parts_list    -- 완료된 파트 목록 조회
├─ SPAN: seaweed.list_parts        -- SeaweedFS 파트 상태 확인
└─ SPAN: api.response              -- 재개 정보 반환
```

**플로우 상세**
```
[클라이언트 측 - 재개 시도]
1. localStorage/IndexedDB에서 sessionId 확인
   │ 없음 → 새 업로드 시작 (1-B 처음부터)
   │ 있음 ↓
   
2. API 호출: GET /multipart/sessions/{sessionId}/status
   │
   ↓
[서버 측 - 세션 상태 확인]
3. upload_sessions 조회 
   │
   ├─ 세션 없음 → 404 반환 → 클라이언트: 새 업로드 시작
   │
   ├─ status = COMPLETED → 이미 완료됨 → fileId 반환
   │
   ├─ status = ABORTED → 중단됨 → 새 업로드 안내
   │
   ├─ status = EXPIRED (expiresAt < NOW()) → 만료됨 → 새 업로드 안내
   │
   └─ status = INIT or UPLOADING → 재개 가능 ↓

4. upload_parts 조회: 완료된 파트 목록 
   SELECT partNumber, etag, bytes 
   FROM upload_parts 
   WHERE sessionId = ? AND status = 'COMPLETED'
   ORDER BY partNumber

5. SeaweedFS 파트 상태 확인 (선택적) 
   - DB의 파트 목록과 실제 저장소 상태 검증
   - 불일치 시 DB 기준으로 재업로드 필요 파트 표시

6. 응답 반환 
   {
     "sessionId": "xxx",
     "status": "UPLOADING",
     "uploadedParts": [
       { "partNumber": 1, "etag": "abc", "bytes": 10485760 },
       { "partNumber": 2, "etag": "def", "bytes": 10485760 }
     ],
     "nextPartNumber": 3,
     "totalParts": 10,
     "uploadedBytes": 20971520,
     "remainingBytes": 83886080,
     "expiresAt": "2024-01-20T12:00:00Z"
   }
```

**클라이언트 재개 처리**
```
[클라이언트]
1. 응답의 uploadedParts 기반으로 로컬 파일에서 미전송 파트 식별
2. nextPartNumber부터 파트 업로드 재개
3. 모든 파트 완료 후 complete 요청
```

**상태 다이어그램**
```
                    ┌─────────────┐
                    │    INIT     │
                    └──────┬──────┘
                           │ 첫 파트 업로드 시작
                           ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   EXPIRED   │◄───│  UPLOADING  │───►│  COMPLETED  │
│  (배치처리)  │    └──────┬──────┘    └─────────────┘
└─────────────┘           │
       ▲                  │ 사용자 명시적 취소
       │                  ▼
       │           ┌─────────────┐
       └───────────│   ABORTED   │
                   └─────────────┘
```

---

###### 1-B-2. 세션 초기화 후 미진행 처리 (INIT 상태 방치)

**시나리오**: initiate 호출 후 파트 업로드를 전혀 진행하지 않은 경우

**Trace/Span 흐름 (배치 작업)**
```
[Batch - traceId: cleanup-xxx]
├─ SPAN: db.expired_init_sessions_select
├─ SPAN: seaweed.abort_multipart (각 세션별)
├─ SPAN: db.session_status_update
└─ SPAN: db.upload_parts_cleanup
```

**플로우 상세**
```
[배치 스케줄러 - 주기: 1시간마다]

1. 만료된 INIT 상태 세션 조회 
   SELECT * FROM upload_sessions
   WHERE status = 'INIT'
     AND expiresAt < NOW()
   LIMIT 100  -- 배치 크기 제한

2. 각 세션별 처리 (반복)
   │
   ├─ [SeaweedFS] Abort Multipart Upload 
   │   - uploadId로 미완료 멀티파트 세션 정리
   │   - 실패해도 계속 진행 (이미 없을 수 있음)
   │
   ├─ [DB] 세션 상태 업데이트 
   │   UPDATE upload_sessions
   │   SET status = 'EXPIRED',
   │       updatedAt = NOW()
   │   WHERE id = ?
   │
   └─ [DB] 파트 레코드 정리 (있다면) 
       DELETE FROM upload_parts
       WHERE sessionId = ?

3. 처리 결과 로깅
   - 정리된 세션 수
   - SeaweedFS 정리 실패 케이스 (별도 알림 필요 시)
```

**방치 방지 전략**
```
┌─────────────────────────────────────────────────────────┐
│ 정책 옵션                                                │
├─────────────────────────────────────────────────────────┤
│ 1. expiresAt 설정                                       │
│    - INIT 상태: initiate 후 24시간                       │
│    - UPLOADING 상태: 마지막 파트 업로드 후 72시간         │
│                                                         │
│ 2. 리마인더 알림 (선택적)                                │
│    - expiresAt 6시간 전 사용자에게 이메일/푸시 알림       │
│    - "업로드가 진행 중입니다. 완료해주세요"               │
│                                                         │
│ 3. 자동 연장 (선택적)                                    │
│    - 파트 업로드 시마다 expiresAt 갱신                   │
│    - 활성 업로드는 만료되지 않도록                        │
└─────────────────────────────────────────────────────────┘
```

---

###### 1-B-3. 파트 업로드 중 미완료 처리 (UPLOADING 상태 방치)

**시나리오**: 일부 파트만 업로드하고 complete를 호출하지 않은 경우

**Trace/Span 흐름 (배치 작업)**
```
[Batch - traceId: cleanup-xxx]
├─ SPAN: db.expired_uploading_sessions_select
├─ SPAN: seaweed.abort_multipart (각 세션별)
├─ SPAN: db.session_status_update
└─ SPAN: db.upload_parts_cleanup
```

**플로우 상세**
```
[배치 스케줄러 - 주기: 1시간마다]

1. 만료된 UPLOADING 상태 세션 조회 
   SELECT s.*, 
          COUNT(p.id) as uploadedPartCount,
          SUM(p.bytes) as uploadedBytes
   FROM upload_sessions s
   LEFT JOIN upload_parts p ON s.id = p.sessionId AND p.status = 'COMPLETED'
   WHERE s.status = 'UPLOADING'
     AND s.expiresAt < NOW()
   GROUP BY s.id
   LIMIT 100

2. 각 세션별 처리 (반복)
   │
   ├─ [SeaweedFS] Abort Multipart Upload 
   │   - 저장된 파트 데이터 삭제
   │   - uploadId 기반 정리
   │
   ├─ [DB] 세션 상태 업데이트 
   │   UPDATE upload_sessions
   │   SET status = 'EXPIRED',
   │       updatedAt = NOW()
   │   WHERE id = ?
   │
   └─ [DB] 파트 레코드 정리 
       DELETE FROM upload_parts
       WHERE sessionId = ?

3. 처리 결과 로깅 및 통계
   {
     "processedSessions": 5,
     "totalReclaimedBytes": 524288000,  // 500MB
     "failedCleanups": []
   }
```

**미완료 업로드 재개 vs 정리 결정 로직**
```
[사용자가 세션 조회 시]
                           │
                           ▼
              ┌────────────────────────┐
              │ expiresAt > NOW() ?    │
              └───────────┬────────────┘
                    │           │
                  Yes          No
                    │           │
                    ▼           ▼
            ┌───────────┐  ┌───────────────┐
            │ 재개 가능  │  │ 만료 안내      │
            │ 파트 목록  │  │ 새 업로드 필요 │
            │ 반환      │  │               │
            └───────────┘  └───────────────┘
```

---

###### 1-B-4. 수동 업로드 취소 (Abort)

**시나리오**: 사용자가 명시적으로 업로드를 취소하는 경우

**Trace/Span 흐름**
```
[Abort - traceId: abort-xxx]
├─ SPAN: api.request_validate
├─ SPAN: db.session_lookup
├─ SPAN: seaweed.abort_multipart
├─ SPAN: db.transaction
│   ├─ db.session_status_update
│   └─ db.upload_parts_cleanup
└─ SPAN: api.response
```

**플로우 상세**
```
[사용자 취소 요청]
Client → API: DELETE /multipart/sessions/{sessionId}

1. 세션 조회 
   │
   ├─ 세션 없음 → 404 반환
   ├─ 이미 COMPLETED → 409 Conflict (파일 삭제 API 안내)
   ├─ 이미 ABORTED/EXPIRED → 200 OK (이미 정리됨)
   └─ INIT/UPLOADING → 취소 처리 ↓

2. SeaweedFS 정리 
   - 업로드된 파트 데이터 삭제
   - 멀티파트 세션 종료

3. DB 트랜잭션 
   │
   ├─ 세션 상태 업데이트 
   │   UPDATE upload_sessions
   │   SET status = 'ABORTED',
   │       updatedAt = NOW()
   │   WHERE id = ?
   │
   └─ 파트 레코드 삭제 
       DELETE FROM upload_parts
       WHERE sessionId = ?

4. 응답 반환 
   {
     "sessionId": "xxx",
     "status": "ABORTED",
     "message": "업로드가 취소되었습니다."
   }
```

---

###### 1-B-5. 멀티파트 엣지 케이스 종합 처리 테이블

| 상태 | 조건 | 사용자 액션 | 시스템 액션 |
|-----|------|-----------|-----------|
| **INIT** | expiresAt > NOW() | 파트 업로드 시작 가능 | 대기 |
| **INIT** | expiresAt < NOW() | 새 업로드 필요 | 배치에서 EXPIRED로 변경 |
| **UPLOADING** | expiresAt > NOW() | 이어받기(Resume) 가능 | 대기 |
| **UPLOADING** | expiresAt < NOW() | 새 업로드 필요 | 배치에서 EXPIRED로 변경 + 파트 정리 |
| **COMPLETED** | - | 파일 다운로드/관리 | 정상 완료 |
| **ABORTED** | - | 새 업로드 필요 | 정리 완료 |
| **EXPIRED** | - | 새 업로드 필요 | 정리 완료 |

---

###### 1-B-6. upload_sessions 엔티티 상태 필드 상세

```
status ENUM:
  - INIT       : initiate 호출됨, 파트 업로드 대기
  - UPLOADING  : 1개 이상 파트 업로드됨, 진행 중
  - COMPLETED  : complete 호출됨, files 생성 완료
  - ABORTED    : 사용자 명시적 취소
  - EXPIRED    : 만료됨, 배치에서 정리됨

expiresAt 정책:
  - initiate 시점: NOW() + 24시간 (기본값)
  - 파트 업로드 시: 갱신하지 않음 (또는 + 24시간 연장 옵션)
  - complete 후: NULL (만료 개념 없음)
```

---

###### 1-B-7. 배치 스케줄러 설정

```
[Cron Job - 만료 세션 정리]

schedule: "0 * * * *"  // 매시 정각
job_name: "cleanup-expired-multipart-sessions"

config:
  batch_size: 100              // 한 번에 처리할 최대 세션 수
  seaweed_timeout_ms: 5000     // SeaweedFS 호출 타임아웃
  retry_failed_cleanup: false  // 실패 시 다음 주기에 재시도
  
alerts:
  - condition: "failed_cleanups > 10"
    action: "send_alert_to_admin"
    message: "멀티파트 정리 실패 다수 발생"
```

##### 2.파일 다운로드 (미리보기 포함)

**핵심 설계: 다운로드/미리보기 시 접근 통계 업데이트 (LRU/LFU 캐시 정책용)**

**플로우 상세**

1)유저(파일 다운로드/미리보기해줘)===> 

[

3)파일 상태 점검 files.state 
  3-1)files.state 값이 TRASHED 인 경우 휴지통에 있는파일 이라고 알림,
  3-2)files.state 값이 DELETED 인 경우 삭제된경우 라고 알림 



1) 캐싱 여부 판단
   4-1)  캐싱 서버 존재하는경우
   file_storage_objects.storageType === CACHE_SEAWEED 
   && file_storage_objects.availabilityStatus === AVAILABLE 으로 판단
   
  4-1-1) 캐시 EVICTING 상태인 경우 (캐시 제거 진행 중)
   file_storage_objects.storageType === CACHE_SEAWEED 
   && file_storage_objects.availabilityStatus === EVICTING
   → 캐시에서 읽지 않고 NAS에서 직접 조회 (4-2와 동일 처리)
   
  4-2) 캐싱 서버에는 존재 하지 않지만 영속성 서버 존재하는경우 

  4-1) 의 결과  FALSE이면서 
file_storage_objects.storageType === NAS && file_storage_objects.availabilityStatus === AVAILABLE 의 결과가  TRUE인경우


4)파일 스트림 획득 및 접근 통계 업데이트

4-1)storageType=CACHE_SEAWEED, availabilityStatus=AVAILABLE 이면 (캐시 히트)
```
→ ★lease 획득 (atomic)★ 
  UPDATE file_storage_objects 
  SET leaseCount = leaseCount + 1
  WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'
  -- 읽기 시작 전에 lease 획득 → Eviction 방지

→ 캐시 파일 서버(SeaweedFS)에서 직접 다운로드 

→ ★접근 통계 업데이트★ 
  UPDATE file_storage_objects 
  SET lastAccessed = NOW(),
      accessCount = accessCount + 1
  WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'


→ ★lease 해제 (atomic, finally 블록)★ 
  UPDATE file_storage_objects 
  SET leaseCount = GREATEST(leaseCount - 1, 0)
  WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'
  -- 스트림 완료/실패 상관없이 반드시 해제 (try-finally)
```

4-2)캐시에 없으면 (MISSING 또는 레코드 없음) → 캐시 미스
```
→ NAS에서 캐시 파일 서버에 복원 후 다운로드 

→ file_storage_objects에 CACHE_SEAWEED 레코드 생성/업데이트 (lease=1로 생성)
  INSERT/UPDATE file_storage_objects (
    fileId, storageType='CACHE_SEAWEED', objectKey=fileId,
    availabilityStatus='AVAILABLE',
    lastAccessed = NOW(),      ← 복원 시점 = 첫 접근
    accessCount = 1,           ← 복원 = 첫 번째 접근
    leaseCount = 1             ← 복원 직후 읽기 중이므로 lease=1
  ) 

→ ★lease 해제 (atomic, finally 블록)★ 
  UPDATE file_storage_objects 
  SET leaseCount = GREATEST(leaseCount - 1, 0)
  WHERE fileId = ? AND storageType = 'CACHE_SEAWEED'
  -- 스트림 완료/실패 상관없이 반드시 해제 (try-finally)
```

4-3) 4-1, 4-2모든 경우 FALSE 인경우 

```
→ 관리자 알림 
```

**접근 통계 활용 (캐시 Eviction 정책)**

| 정책 | 기준 필드 | 설명 |
|------|----------|------|
| LRU | lastAccessed | 가장 오래 접근되지 않은 파일 우선 삭제 |
| LFU | accessCount | 가장 적게 접근된 파일 우선 삭제 |
| FIFO | createdAt | 가장 먼저 캐시된 파일 우선 삭제 |

*주의*
- **접근 통계 업데이트**: 다운로드/미리보기 성공 시에만 업데이트
- **트랜잭션 분리**: 파일 스트림 응답과 별개로 비동기 업데이트 가능 (성능 최적화)
- **캐시 정책 연동**: eviction.worker.ts에서 lastAccessed, accessCount 기준으로 삭제 대상 선정

##### 3.파일명 변경

**API 요청**
```
PUT /files/{fileId}/rename
Body: { 
  newName: "새파일명.pdf",
  conflictStrategy: "ERROR" | "RENAME"  // 선택사항, 기본값: ERROR
}
```

**플로우**

1)유저(파일명 변경해줘)===> 

2)★트랜잭션 내에서 검증 + 처리★ (API 1회 호출로 완료)
```
┌─────────────────────────────────────────────────────────────────────┐
│  [동일 파일명 충돌 처리]                                               │
│                                                                     │
│  conflictStrategy 옵션:                                             │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ ERROR (기본값):                                                 ││
│  │   → 409 Conflict + "동일한 파일명이 존재합니다"                  ││
│  │   → 프론트엔드에서 사용자에게 다른 이름 입력 요청                ││
│  │                                                                 ││
│  │ RENAME:                                                         ││
│  │   → 파일명 자동 변경: "file.txt" → "file (1).txt"               ││
│  │   → 중복 번호 자동 증가: (1), (2), (3)...                       ││
│  │   → 변경된 이름으로 진행                                        ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**응답 시나리오**
```
// 성공
200 OK
{ success: true, file: { id, name, folderId, ... } }

// 동일 파일명 존재 (conflictStrategy=ERROR)
409 Conflict
{
  error: "DUPLICATE_FILENAME_EXISTS",
  message: "동일한 파일명이 이미 존재합니다",
  existingFile: { id, name, mimeType, modifiedAt }
}

// NAS 동기화 중
409 Conflict
{ error: "FILE_SYNCING", message: "파일이 동기화 중입니다" }

// 파일 없음
404 Not Found
{ error: "FILE_NOT_FOUND", message: "파일을 찾을 수 없습니다" }
```

3)★단일 트랜잭션으로 처리★
```
=== BEGIN TRANSACTION ===

-- Step 0: 대상 파일 락 획득 (Race Condition 방지)
SELECT * FROM files WHERE id = :fileId FOR UPDATE;
-- 파일이 없으면 404 반환

-- Step 1: NAS 동기화 상태 체크
SELECT * FROM file_storage_objects 
WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;
-- SYNCING이면 409 Conflict (FILE_SYNCING) 반환

-- Step 2: ★동일 파일명 존재 확인★

  SELECT * FROM files 
WHERE folderId = :targetFolderId 
  AND name = :fileName 
  AND mimeType = :mimeType 
  AND id != :fileId           -- 자기 자신 제외
  AND state = 'ACTIVE';

-- 충돌 발생 시 conflictStrategy에 따라 처리:
┌─────────────────────────────────────────────────────────────────────┐
│ conflictStrategy = 'ERROR' (기본값):                                 │
│   → ROLLBACK + 409 Conflict 반환                                    │
│   → { error: "DUPLICATE_FILENAME_EXISTS", existingFile: {...} }     │
│                                                                     │
│ conflictStrategy = 'RENAME':                                        │
│   → 자동 이름 생성: "file.txt" → "file (1).txt"                     │
│   → 중복 번호 자동 증가 (1), (2), (3)...                            │
│   → 변경된 이름으로 계속 진행                                        │
└─────────────────────────────────────────────────────────────────────┘

-- Step 3: 파일명 업데이트
UPDATE files SET name = :finalName WHERE id = :fileId;

-- Step 4: NAS 경로 업데이트 + 동기화 상태
UPDATE file_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING'
WHERE fileId = :fileId AND storageType = 'NAS';


=== COMMIT ===
```

4)트랜잭션 커밋 후 Redis Queue (Bull) 등록
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,  ← 작업 로그 ID 전달
  traceId, aggregateType: 'FILE', aggregateId: fileId,
  eventType: 'NAS_SYNC_RENAME',
  payload: { oldPath, newPath, fileName }
}, { 
  attempts: 3,              ← 최대 3회 재시도
  backoff: { type: 'exponential', delay: 5000 },
  removeOnComplete: true,
  removeOnFail: false       ← 실패 기록 유지
});
```

5)Bull Worker NAS 동기화 처리
```
5-1) 성공 시:
    - UPDATE file_storage_objects 
      SET availabilityStatus='AVAILABLE', objectKey=실제NAS경로
      WHERE fileId = ? AND storageType = 'NAS'

5-2) 최종 실패 시 (3회 재시도 소진):
    - UPDATE file_storage_objects SET availabilityStatus='ERROR'
      WHERE fileId = ? AND storageType = 'NAS'
    - 관리자 Alert 발송
```

*주의*
- **FOR UPDATE**: 동시 요청 직렬화, 업로드 완료 대기
- 캐시(SeaweedFS)의 objectKey는 fileId 기반이므로 변경 불필요
- NAS 동기화: Bull 큐 (3회 재시도, 최종 실패 시 Alert + ERROR)

##### 4.파일 삭제 (휴지통 행)
1)유저(파일 삭제해줘)===> 

2)★단일 트랜잭션으로 처리★
```
=== BEGIN TRANSACTION ===

0. ★FOR UPDATE 락 획득★ (Race Condition 방지)
   SELECT * FROM files WHERE id = ? FOR UPDATE;
   -- 다른 트랜잭션(업로드/수정/삭제)이 완료될 때까지 대기
   -- 파일이 없으면 404 반환

1. file_storage_objects NAS 레코드 상태 체크
   SELECT * FROM file_storage_objects 
   WHERE fileId = ? AND storageType = 'NAS' FOR UPDATE;
   -- SYNCING이면 409 Conflict 반환

2. UPDATE files SET state=TRASHED

3. UPDATE file_storage_objects SET availabilityStatus=SYNCING
   WHERE fileId = ? AND storageType = 'NAS'

=== COMMIT ===
```

3)트랜잭션 커밋 후 Redis Queue (Bull) 등록
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,  ← 작업 로그 ID 전달
  traceId, aggregateType: 'FILE', aggregateId: fileId,
  eventType: 'NAS_MOVE_TO_TRASH',
  payload: { sourcePath, trashPath, fileName }
}, { 
  attempts: 3,              ← 최대 3회 재시도
  backoff: { type: 'exponential', delay: 5000 },
  removeOnComplete: true,
  removeOnFail: false       ← 실패 기록 유지
});
```

4)Bull Worker NAS 동기화 처리 (NAS의 .trash 폴더로 이동)
```
4-1) 성공 시:
    - UPDATE file_storage_objects 
      SET availabilityStatus='AVAILABLE', objectKey=trashPath
      WHERE fileId = ? AND storageType = 'NAS'

4-2) 최종 실패 시 (3회 재시도 소진):lastError=에러메시지
    - UPDATE file_storage_objects SET availabilityStatus='ERROR'
      WHERE fileId = ? AND storageType = 'NAS'
    - 관리자 Alert 발송
```

*주의*
- **FOR UPDATE**: 동시 요청 직렬화, 업로드 완료 대기
- 소프트 삭제(TRASHED) 후 휴지통에서 영구삭제 시 물리 파일 제거
- 캐시(SeaweedFS) 파일은 휴지통 이동 시점에 즉시 삭제하거나 지연 삭제 정책 적용

##### 5.파일 다른 폴더로 이동

**API 요청**
```
POST /files/{fileId}/move
Body: { 
  targetFolderId: "대상폴더UUID",
  conflictStrategy: "ERROR" | "OVERWRITE" | "RENAME" | "SKIP"  // 선택사항, 기본값: ERROR
}
```

**플로우**

0)유저(파일 다른 폴더로 이동해줘)===> 

1)★트랜잭션 내에서 검증 + 처리★ (API 1회 호출로 완료)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [검증 및 충돌 처리]                                                  │
│                                                                     │
│  검증 1: 대상 폴더 존재 확인                                          │
│  ────────────────────────                                           │
│  - 없음 → 404 + "대상 폴더가 존재하지 않습니다"                       │
│  - 프론트엔드에서 폴더 트리 UI로 선택하면 발생 확률 낮음              │
│                                                                     │
│  검증 2: 동일 파일 존재 확인 (name + mimeType)                        │
│  ────────────────────────                                           │
│  - 충돌 발생 시 conflictStrategy에 따라 처리:                         │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ ERROR (기본값):                                                 ││
│  │   → 409 Conflict 반환                                           ││
│  │   → 프론트엔드에서 사용자에게 선택지 제공                        ││
│  │                                                                 ││
│  │ OVERWRITE:                                                      ││
│  │   → 기존 파일을 휴지통으로 이동 (소프트 삭제)                    ││
│  │   → 새 파일 이동 진행                                           ││
│  │   → 하나의 트랜잭션으로 처리                                    ││
│  │                                                                 ││
│  │ RENAME:                                                         ││
│  │   → 파일명 자동 변경: "file.txt" → "file (1).txt"               ││
│  │   → 중복 번호 자동 증가: (1), (2), (3)...                       ││
│  │   → 변경된 이름으로 이동 진행                                   ││
│  │                                                                 ││
│  │ SKIP:                                                           ││
│  │   → 200 OK + { skipped: true, reason: "동일 파일 존재" }        ││
│  │   → 이동하지 않고 기존 파일 유지                                 ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

**응답 시나리오**
```
// 성공
200 OK
{ success: true, file: { id, name, folderId, ... } }

// 성공 (SKIP)
200 OK
{ success: true, skipped: true, reason: "DUPLICATE_FILE_EXISTS" }

// 대상 폴더 없음
404 Not Found
{ error: "TARGET_FOLDER_NOT_FOUND", message: "대상 폴더가 존재하지 않습니다" }

// 동일 파일 존재 (conflictStrategy=ERROR)
409 Conflict
{
  error: "DUPLICATE_FILE_EXISTS",
  message: "동일한 파일이 이미 존재합니다",
  existingFile: { id, name, mimeType, size, modifiedAt },
  availableActions: ["OVERWRITE", "RENAME", "SKIP"]
}

// NAS 동기화 중
409 Conflict
{ error: "FILE_SYNCING", message: "파일이 동기화 중입니다" }

// 파일 없음
404 Not Found
{ error: "FILE_NOT_FOUND", message: "이동할 파일을 찾을 수 없습니다" }
```

**프론트엔드 충돌 처리 흐름**
```
┌─────────────────────────────────────────────────────────────────────┐
│  [충돌 발생 시 다이얼로그]                                            │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                                                             │   │
│  │  ⚠️  동일한 파일이 이미 존재합니다                            │   │
│  │                                                             │   │
│  │  대상 폴더: /프로젝트A/문서/                                 │   │
│  │  파일명: report.pdf                                         │   │
│  │                                                             │   │
│  │  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐           │   │
│  │  │  덮어쓰기    │ │ 이름 변경   │ │   취소      │           │   │
│  │  │ (OVERWRITE) │ │  (RENAME)   │ │   (SKIP)    │           │   │
│  │  └─────────────┘ └─────────────┘ └─────────────┘           │   │
│  │                                                             │   │
│  │  □ 이후 같은 상황에서 이 선택 기억하기                       │   │
│  │                                                             │   │
│  └─────────────────────────────────────────────────────────────┘   │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

2)★단일 트랜잭션으로 처리★
```
=== BEGIN TRANSACTION ===

-- Step 0: 대상 폴더 존재 확인
SELECT * FROM folders WHERE id = :targetFolderId AND state = 'ACTIVE';
-- 없으면 404 반환 (TARGET_FOLDER_NOT_FOUND)

-- Step 1: 이동할 파일 락 획득 (Race Condition 방지)
SELECT * FROM files WHERE id = :fileId FOR UPDATE;
-- 파일이 없으면 404 반환

-- Step 2: NAS 동기화 상태 체크
SELECT * FROM file_storage_objects 
WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;
-- SYNCING이면 409 Conflict (FILE_SYNCING) 반환

-- Step 3: ★동일 파일 존재 확인★
SELECT * FROM files 
WHERE folderId = :targetFolderId 
  AND name = :fileName 
  AND mimeType = :mimeType 
  AND state = 'ACTIVE';

-- 충돌 발생 시 conflictStrategy에 따라 처리:
┌─────────────────────────────────────────────────────────────────────┐
│ conflictStrategy = 'ERROR' (기본값):                                 │
│   → ROLLBACK + 409 Conflict 반환                                    │
│   → { error: "DUPLICATE_FILE_EXISTS", existingFile: {...} }         │
│                                                                     │
│ conflictStrategy = 'OVERWRITE':                                     │
│   → 기존 파일 락: SELECT * FROM files WHERE id = :existingId FOR UPDATE
│   → 기존 파일 휴지통 이동: UPDATE files SET state='TRASHED'          │
│   → 새 파일 이동 계속 진행                                           │
│                                                                     │
│ conflictStrategy = 'RENAME':                                        │
│   → 자동 이름 생성: "file.txt" → "file (1).txt"                     │
│   → 중복 번호 자동 증가 (1), (2), (3)...                            │
│   → 변경된 이름으로 계속 진행                                        │
│                                                                     │
│ conflictStrategy = 'SKIP':                                          │
│   → ROLLBACK + 200 OK 반환                                          │
│   → { success: true, skipped: true, reason: "DUPLICATE_FILE_EXISTS" }
└─────────────────────────────────────────────────────────────────────┘

-- Step 4: 파일 이동 (폴더 변경)
UPDATE files SET folderId = :targetFolderId, name = :finalName 
WHERE id = :fileId;

-- Step 5: NAS 경로 업데이트 + 동기화 상태
UPDATE file_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING'
WHERE fileId = :fileId AND storageType = 'NAS';


-- (OVERWRITE인 경우 추가) 덮어쓴 파일의 휴지통 동기화도 등록


=== COMMIT ===
```

3)트랜잭션 커밋 후 Redis Queue (Bull) 등록
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,  ← 작업 로그 ID 전달
  traceId, aggregateType: 'FILE', aggregateId: fileId,
  eventType: 'NAS_SYNC_MOVE',
  payload: { sourcePath, targetPath, fileName }
}, { 
  attempts: 3,              ← 최대 3회 재시도
  backoff: { type: 'exponential', delay: 5000 },
  removeOnComplete: true,
  removeOnFail: false       ← 실패 기록 유지
});
```

4)Bull Worker NAS 동기화 처리
```
4-1) 성공 시:
    - UPDATE file_storage_objects 
      SET availabilityStatus='AVAILABLE', objectKey=targetPath
      WHERE fileId = ? AND storageType = 'NAS'

4-2) 최종 실패 시 (3회 재시도 소진):
    - UPDATE file_storage_objects SET availabilityStatus='ERROR'
      WHERE fileId = ? AND storageType = 'NAS'
    - 관리자 Alert 발송
```

*주의*
- **FOR UPDATE**: 동시 요청 직렬화, 업로드 완료 대기
- **충돌 처리**: conflictStrategy로 덮어쓰기/이름변경/건너뛰기 지원
- **OVERWRITE 시**: 기존 파일 휴지통 이동 + 새 파일 이동이 하나의 트랜잭션으로 처리
- **RENAME 시**: 자동 생성된 파일명이 응답에 포함됨
- 캐시(SeaweedFS)의 objectKey는 fileId 기반이므로 변경 불필요
- NAS 동기화: Bull 큐 (3회 재시도, 최종 실패 시 Alert + ERROR)



#### ㄴ.폴더 ===============================

**폴더 충돌 처리 전략 (공통)**
```
┌─────────────────────────────────────────────────────────────────────┐
│  [동일 이름 폴더 충돌 처리]                                            │
│                                                                     │
│  conflictStrategy 옵션:                                             │
│  ┌─────────────────────────────────────────────────────────────────┐│
│  │ ERROR (기본값):                                                 ││
│  │   → 409 Conflict + "동일한 이름의 폴더가 존재합니다"             ││
│  │   → 프론트엔드에서 사용자에게 다른 이름 입력 요청                ││
│  │                                                                 ││
│  │ RENAME:                                                         ││
│  │   → 폴더명 자동 변경: "folder" → "folder (1)"                   ││
│  │   → 중복 번호 자동 증가: (1), (2), (3)...                       ││
│  │   → 변경된 이름으로 진행                                        ││
│  │                                                                 
│  │                                                                 ││
│  │ SKIP (폴더 이동 시에만):                                         ││
│  │   → 이동하지 않고 건너뛰기                                       ││
│  └─────────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

##### 1.폴더 생성

**API 요청**
```
POST /folders
Body: { 
  name: "새폴더",
  parentId: "상위폴더UUID",
  conflictStrategy: "ERROR" | "RENAME"  // 선택사항, 기본값: ERROR
}
```

**플로우**

1)유저(폴더 생성해줘)===> 

2)★트랜잭션 내에서 검증 + 처리★

**응답 시나리오**
```
// 성공
201 Created
{ success: true, folder: { id, name, parentId, path, ... } }

// 상위 폴더 없음
404 Not Found
{ error: "PARENT_FOLDER_NOT_FOUND", message: "상위 폴더가 존재하지 않습니다" }

// 동일 이름 폴더 존재 (conflictStrategy=ERROR)
409 Conflict
{
  error: "DUPLICATE_FOLDER_EXISTS",
  message: "동일한 이름의 폴더가 이미 존재합니다",
  existingFolder: { id, name, path }
}
```

3)★UUID 미리 생성★
```
const folderId = uuid.v4();
```

4)★DB 트랜잭션★
```
=== BEGIN TRANSACTION ===

-- Step 0: 상위 폴더 존재 확인
SELECT * FROM folders WHERE id = :parentId AND state = 'ACTIVE';
-- 없으면 404 반환 (PARENT_FOLDER_NOT_FOUND)
-- parentId가 null이면 루트 폴더 생성 (이 체크 건너뜀)

-- Step 1: ★동일 이름 폴더 존재 확인★
SELECT * FROM folders 
WHERE parentId = :parentId 
  AND name = :folderName 
  AND state = 'ACTIVE';

-- 충돌 발생 시 conflictStrategy에 따라 처리:
┌─────────────────────────────────────────────────────────────────────┐
│ conflictStrategy = 'ERROR' (기본값):                                 │
│   → ROLLBACK + 409 Conflict 반환                                    │
│   → { error: "DUPLICATE_FOLDER_EXISTS", existingFolder: {...} }     │
│                                                                     │
│ conflictStrategy = 'RENAME':                                        │
│   → 자동 이름 생성: "folder" → "folder (1)"                         │
│   → 중복 번호 자동 증가 (1), (2), (3)...                            │
│   → 변경된 이름으로 계속 진행                                        │
└─────────────────────────────────────────────────────────────────────┘

-- Step 2: 폴더 생성
INSERT folders (id=folderId, name=:finalName, parentId, path, state=ACTIVE);

-- Step 3: NAS 동기화 객체 생성
INSERT folder_storage_objects (
  folderId, storageType=NAS, objectKey=nasPath,
  availabilityStatus=SYNCING  ← 동시성 제어용
);


=== COMMIT ===
```

5)트랜잭션 커밋 후 Bull 즉시 처리 (1회만)
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,
  aggregateType: 'FOLDER', eventType: 'NAS_SYNC_MKDIR',
  payload: { nasPath, folderName }
}, { attempts: 3, removeOnComplete: true, removeOnFail: false });
```

6)Bull Worker가 NAS 동기화 처리 (최대 3회 재시도)
- 성공 시: folder_storage_objects.availabilityStatus='AVAILABLE'
- 최종 실패 시: Alert 발송 + folder_storage_objects.availabilityStatus='ERROR'

*주의*
- **상위 폴더 검증**: parentId가 유효한 폴더인지 트랜잭션 내에서 확인
- **동일 이름 체크**: 같은 부모 폴더 내 동일 이름 폴더 존재 여부 확인
- **folder_storage_objects**: NAS 동기화 상태 + 동시성 제어

##### 2.폴더 명 수정

**API 요청**
```
PUT /folders/{folderId}/rename
Body: { 
  newName: "새폴더명",
  conflictStrategy: "ERROR" | "RENAME"  // 선택사항, 기본값: ERROR
}
```

**플로우**

1)유저(폴더 명 수정해줘)===> 

2)★트랜잭션 내에서 검증 + 처리★

**응답 시나리오**
```
// 성공
200 OK
{ success: true, folder: { id, name, path, ... } }

// 폴더 없음
404 Not Found
{ error: "FOLDER_NOT_FOUND", message: "폴더를 찾을 수 없습니다" }

// 동일 이름 폴더 존재 (conflictStrategy=ERROR)
409 Conflict
{
  error: "DUPLICATE_FOLDER_EXISTS",
  message: "동일한 이름의 폴더가 이미 존재합니다",
  existingFolder: { id, name, path }
}

// NAS 동기화 중
409 Conflict
{ error: "FOLDER_SYNCING", message: "폴더가 동기화 중입니다" }
```

3)★DB 트랜잭션★
```
=== BEGIN TRANSACTION ===

-- Step 0: 대상 폴더 락 획득 (Race Condition 방지)
SELECT * FROM folders WHERE id = :folderId FOR UPDATE;
-- 폴더가 없으면 404 반환

-- Step 1: NAS 동기화 상태 체크
SELECT * FROM folder_storage_objects 
WHERE folderId = :folderId AND storageType = 'NAS' FOR UPDATE;
-- SYNCING이면 409 Conflict (FOLDER_SYNCING) 반환

-- Step 2: ★동일 이름 폴더 존재 확인★
SELECT * FROM folders 
WHERE parentId = :currentParentId 
  AND name = :newName 
  AND id != :folderId           -- 자기 자신 제외
  AND state = 'ACTIVE';

-- 충돌 발생 시 conflictStrategy에 따라 처리:
┌─────────────────────────────────────────────────────────────────────┐
│ conflictStrategy = 'ERROR' (기본값):                                 │
│   → ROLLBACK + 409 Conflict 반환                                    │
│   → { error: "DUPLICATE_FOLDER_EXISTS", existingFolder: {...} }     │
│                                                                     │
│ conflictStrategy = 'RENAME':                                        │
│   → 자동 이름 생성: "folder" → "folder (1)"                         │
│   → 중복 번호 자동 증가 (1), (2), (3)...                            │
│   → 변경된 이름으로 계속 진행                                        │
└─────────────────────────────────────────────────────────────────────┘

-- Step 3: 폴더명 업데이트
UPDATE folders SET name = :finalName, path = :newPath WHERE id = :folderId;

-- Step 4: 하위 폴더/파일 path 일괄 업데이트 (재귀적)
UPDATE folders SET path = REPLACE(path, :oldPath, :newPath) 
WHERE path LIKE :oldPath || '/%';

UPDATE files f SET ... -- 필요시 관련 경로 업데이트

-- Step 5: NAS 경로 업데이트 + 동기화 상태
UPDATE folder_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING'
WHERE folderId = :folderId AND storageType = 'NAS';


=== COMMIT ===
```

4)트랜잭션 커밋 후 Bull 즉시 처리 (1회만)
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,
  aggregateType: 'FOLDER', eventType: 'NAS_SYNC_RENAME_DIR',
  payload: { oldPath, newPath }
}, { attempts: 3, removeOnComplete: true, removeOnFail: false });
```

5)Bull Worker가 NAS 동기화 처리 (최대 3회 재시도, 최종 실패 시 Alert + ERROR)

*주의*
- **FOR UPDATE**: 동시 요청 직렬화, 폴더 생성 완료 대기
- **동일 이름 체크**: 같은 부모 폴더 내 동일 이름 폴더 존재 여부 확인
- **하위 path 업데이트**: 폴더명 변경 시 하위 폴더/파일의 path도 일괄 업데이트 필요
- **동시성 제어**: SYNCING 상태면 수정 차단

##### 3.폴더 이동

**API 요청**
```
POST /folders/{folderId}/move
Body: { 
  targetParentId: "대상상위폴더UUID",
  conflictStrategy: "ERROR" | "RENAME" |  "SKIP"  // 선택사항, 기본값: ERROR
}
```

**플로우**

1)유저(폴더 이동해줘)===> 

2)★트랜잭션 내에서 검증 + 처리★

**응답 시나리오**
```
// 성공
200 OK
{ success: true, folder: { id, name, parentId, path, ... } }

// 성공 (SKIP)
200 OK
{ success: true, skipped: true, reason: "DUPLICATE_FOLDER_EXISTS" }

// 이동할 폴더 없음
404 Not Found
{ error: "FOLDER_NOT_FOUND", message: "이동할 폴더를 찾을 수 없습니다" }

// 대상 상위 폴더 없음
404 Not Found
{ error: "TARGET_FOLDER_NOT_FOUND", message: "대상 폴더가 존재하지 않습니다" }

// 동일 이름 폴더 존재 (conflictStrategy=ERROR)
409 Conflict
{
  error: "DUPLICATE_FOLDER_EXISTS",
  message: "동일한 이름의 폴더가 이미 존재합니다",
  existingFolder: { id, name, path },
  availableActions: ["RENAME", "MERGE", "SKIP"]
}

// 순환 이동 방지 (자기 자신 또는 하위로 이동 시도)
409 Conflict
{ error: "CIRCULAR_MOVE", message: "폴더를 자기 자신 또는 하위 폴더로 이동할 수 없습니다" }

// NAS 동기화 중
409 Conflict
{ error: "FOLDER_SYNCING", message: "폴더가 동기화 중입니다" }
```

3)★DB 트랜잭션★
```
=== BEGIN TRANSACTION ===

-- Step 0: 대상 상위 폴더 존재 확인
SELECT * FROM folders WHERE id = :targetParentId AND state = 'ACTIVE';
-- 없으면 404 반환 (TARGET_FOLDER_NOT_FOUND)

-- Step 1: 이동할 폴더 락 획득 (Race Condition 방지)
SELECT * FROM folders WHERE id = :folderId FOR UPDATE;
-- 폴더가 없으면 404 반환

-- Step 2: 순환 이동 방지 체크
-- targetParentId가 folderId의 하위 폴더인지 확인
SELECT * FROM folders 
WHERE id = :targetParentId AND path LIKE (SELECT path FROM folders WHERE id = :folderId) || '/%';
-- 결과가 있으면 409 Conflict (CIRCULAR_MOVE)

-- Step 3: NAS 동기화 상태 체크
SELECT * FROM folder_storage_objects 
WHERE folderId = :folderId AND storageType = 'NAS' FOR UPDATE;
-- SYNCING이면 409 Conflict (FOLDER_SYNCING) 반환

-- Step 4: ★동일 이름 폴더 존재 확인★
SELECT * FROM folders 
WHERE parentId = :targetParentId 
  AND name = :folderName 
  AND state = 'ACTIVE';

-- 충돌 발생 시 conflictStrategy에 따라 처리:
┌─────────────────────────────────────────────────────────────────────┐
│ conflictStrategy = 'ERROR' (기본값):                                 │
│   → ROLLBACK + 409 Conflict 반환                                    │
│   → { error: "DUPLICATE_FOLDER_EXISTS", existingFolder: {...} }     │
│                                                                     │
│ conflictStrategy = 'RENAME':                                        │
│   → 자동 이름 생성: "folder" → "folder (1)"                         │
│   → 중복 번호 자동 증가 (1), (2), (3)...                            │
│   → 변경된 이름으로 이동 진행                                        │
│                                                                     │                                │
│                                                                     │
│ conflictStrategy = 'SKIP':                                          │
│   → ROLLBACK + 200 OK 반환                                          │
│   → { success: true, skipped: true, reason: "DUPLICATE_FOLDER_EXISTS" }
└─────────────────────────────────────────────────────────────────────┘

-- Step 5: 폴더 이동 (부모 변경)
UPDATE folders SET parentId = :targetParentId, name = :finalName, path = :newPath 
WHERE id = :folderId;

-- Step 6: 하위 폴더/파일 path 일괄 업데이트 (재귀적)
UPDATE folders SET path = REPLACE(path, :oldPath, :newPath) 
WHERE path LIKE :oldPath || '/%';

-- Step 7: NAS 경로 업데이트 + 동기화 상태
UPDATE folder_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING'
WHERE folderId = :folderId AND storageType = 'NAS';


=== COMMIT ===
```

4)트랜잭션 커밋 후 Bull 즉시 처리 (1회만)
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,
  aggregateType: 'FOLDER', eventType: 'NAS_SYNC_MOVE_DIR',
  payload: { sourcePath, targetPath }
}, { attempts: 3, removeOnComplete: true, removeOnFail: false });
```

5)Bull Worker가 NAS 동기화 처리 (최대 3회 재시도, 최종 실패 시 Alert + ERROR)

*주의*
- **FOR UPDATE**: 동시 요청 직렬화, 폴더 생성 완료 대기
- **순환 이동 방지**: 자기 자신 또는 하위 폴더로 이동 시도 차단
- **동일 이름 체크**: 대상 상위 폴더 내 동일 이름 폴더 존재 여부 확인
- **하위 path 업데이트**: 폴더 이동 시 하위 폴더/파일의 path도 일괄 업데이트 필요
- **동시성 제어**: SYNCING 상태면 수정 차단
- **MERGE 전략**: 복잡한 병합 로직, 파일 충돌 처리 필요

##### 4.폴더 삭제 (휴지통 행)

**API 요청**
```
DELETE /folders/{folderId}
```

**플로우**

1)유저(폴더 삭제해줘)===> 

2)★트랜잭션 내에서 검증 + 처리★

**응답 시나리오**
```
// 성공
200 OK
{ success: true, folder: { id, name, deletedChildCount: 5 } }

// 폴더 없음
404 Not Found
{ error: "FOLDER_NOT_FOUND", message: "폴더를 찾을 수 없습니다" }

// NAS 동기화 중
409 Conflict
{ error: "FOLDER_SYNCING", message: "폴더가 동기화 중입니다" }

// 하위 파일 동기화 중
409 Conflict
{ 
  error: "CHILD_FILES_SYNCING", 
  message: "하위 파일 중 동기화 중인 파일이 있습니다",
  syncingFiles: [{ id, name }, ...]
}
```

3)★DB 트랜잭션★
```
=== BEGIN TRANSACTION ===

-- Step 0: 대상 폴더 존재 확인 + 락 획득 (Race Condition 방지)
SELECT * FROM folders WHERE id = :folderId AND state = 'ACTIVE' FOR UPDATE;
-- 폴더가 없거나 이미 삭제됨 → 404 반환

-- Step 1: NAS 동기화 상태 체크
SELECT * FROM folder_storage_objects 
WHERE folderId = :folderId AND storageType = 'NAS' FOR UPDATE;
-- SYNCING이면 409 Conflict (FOLDER_SYNCING) 반환

-- Step 2: 하위 파일들도 락 획득 (폴더 삭제 시 하위 파일 보호)
SELECT * FROM files WHERE folderId = :folderId FOR UPDATE;

-- Step 3: 하위 파일들의 NAS 동기화 상태 체크
SELECT f.id, f.name FROM files f
JOIN file_storage_objects fso ON f.id = fso.fileId
WHERE f.folderId = :folderId 
  AND fso.storageType = 'NAS' 
  AND fso.availabilityStatus = 'SYNCING';
-- 동기화 중인 하위 파일이 있으면 409 Conflict (CHILD_FILES_SYNCING)

-- Step 4: 폴더 휴지통 이동
UPDATE folders SET state = 'TRASHED' WHERE id = :folderId;

-- Step 5: NAS 동기화 상태 업데이트
UPDATE folder_storage_objects 
SET availabilityStatus = 'SYNCING'
WHERE folderId = :folderId AND storageType = 'NAS';

-- Step 6: 하위 파일 일괄 휴지통 이동
UPDATE files SET state = 'TRASHED' WHERE folderId = :folderId;

-- Step 7: 하위 파일 NAS 동기화 상태 업데이트
UPDATE file_storage_objects 
SET availabilityStatus = 'SYNCING' 
WHERE fileId IN (SELECT id FROM files WHERE folderId = :folderId) 
  AND storageType = 'NAS';


=== COMMIT ===
```

4)트랜잭션 커밋 후 Bull 즉시 처리 (1회만)
```
await nasQueue.add('sync', {
  syncEventId: syncEvent.id,
  aggregateType: 'FOLDER', eventType: 'NAS_SYNC_TRASH_DIR',
  payload: { sourcePath, trashPath, childCount }
}, { attempts: 3, removeOnComplete: true, removeOnFail: false });
```

5)Bull Worker가 NAS 동기화 처리 (최대 3회 재시도, 최종 실패 시 Alert + ERROR)
- 성공 시: folder_storage_objects + 하위 file_storage_objects 모두 AVAILABLE로 업데이트

*주의*
- **폴더 존재 확인**: 삭제할 폴더가 존재하고 ACTIVE 상태인지 확인
- **FOR UPDATE**: 동시 요청 직렬화, 폴더 + 하위 파일 보호
- **하위 파일 동기화 체크**: 하위 파일 중 동기화 중인 파일이 있으면 삭제 차단
- **재귀 처리**: 하위 폴더/파일도 재귀적으로 휴지통 처리 필요
- **동시성 제어**: SYNCING 상태면 수정 차단

##### 5.폴더 및 파일(특정경로 폴더 하위) 조회
1)유저(해당 경로(폴더) 아래 파일들 조회해줘)===> 
2)폴더메타데이터를 이용 2가지 list (1.상위 폴더 리스트, 2.하위폴더 리스트)
3)files 테이블에서 folderId로 해당 폴더의 파일 목록 조회 (state=ACTIVE만)
4)file_storage_objects JOIN하여 각 파일의 저장소별 가용성 정보 포함 가능
5)folder_storage_objects JOIN하여 각 폴더의 NAS 동기화 상태 포함 가능

*참고: 조회는 이력 기록 대상 아님 (필요시 별도 access_logs 테이블 활용)*

**API 응답 예시 (storageStatus 포함)**
```
{
  "folders": [
    {
      "id": "folder-uuid",
      "name": "documents",
      "storageStatus": {
        "nas": "AVAILABLE"  ← folder_storage_objects에서 조회
      }
    }
  ],
  "files": [
    {
      "id": "file-uuid",
      "name": "report.pdf",
      "storageStatus": {
        "cache": "AVAILABLE",  ← file_storage_objects 캐시 상태
        "nas": "SYNCING"       ← file_storage_objects NAS 상태
      }
    }
  ]
}
```




#### ㄹ.기타-IP 접근권한 체크========================================

##### 1.IP 접근권한 정책 생성
1)화이트리스트 ===현시점 반영
2)블랙리스트 정책 ==현시점 반영

##### 2.IP 접근권한 룰(정책에 속해 있는 규칙(=ip주소들))생성,수정,삭제
1)유저(IP 접근권한 체크해줘)===> 
2)IP 접근권한 정책 체크(DB)
3)(결과에 따라서)IP 접근권한 체크 결과 반환



#### ㅁ.NAS 체크========================================

##### 1.NAS 헬스체크
1)NAS서버에 .temp파일 생성,삭제 처리 기능 구현 여부및 소요시간 여부를 통한 헬스체크

##### 2.NAS 용량 확인
1)운영환경(윈도우,리눅스)환경별 대응처리 

#### 3.NAS  설정




