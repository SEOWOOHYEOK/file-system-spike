# 큐 관리 시스템

## 개요

NAS 동기화 작업을 위한 Bull Queue 관리 시스템입니다.
- **핵심 원칙**: 실패 시 큐 정지 → 관리자 개입 → 수동 해제
- **목적**: 연쇄 실패 방지, 데이터 정합성 보장, 원인 파악 시간 확보

---

## 아키텍처

```
┌─────────────────────────────────────────────────────────────────────┐
│  [NAS 동기화 큐 아키텍처]                                             │
│                                                                     │
│  API Request                                                        │
│       ↓                                                             │
│  ┌───────────────┐                                                  │
│  │ DB 트랜잭션    │ files/folders + sync_events INSERT              │
│  └───────┬───────┘                                                  │
│          ↓                                                          │
│  ┌───────────────┐                                                  │
│  │ Bull Queue    │ nasQueue.add('sync', {...})                      │
│  │ (Redis)       │                                                  │
│  └───────┬───────┘                                                  │
│          ↓                                                          │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │ Bull Worker                                                    │ │
│  │ ┌─────────────────────────────────────────────────────────┐   │ │
│  │ │ 처리 성공 → sync_events.status = DONE                   │   │ │
│  │ │          → file_storage_objects.availabilityStatus      │   │ │
│  │ │             = AVAILABLE                                 │   │ │
│  │ ├─────────────────────────────────────────────────────────┤   │ │
│  │ │ 처리 실패 (1~2회) → Bull 자동 재시도 (지수 백오프)       │   │ │
│  │ ├─────────────────────────────────────────────────────────┤   │ │
│  │ │ ★최종 실패 (3회)★                                       │   │ │
│  │ │   → sync_events.status = FAILED                         │   │ │
│  │ │   → file_storage_objects.availabilityStatus = ERROR     │   │ │
│  │ │   → ★큐 일시정지 (pause)★                               │   │ │
│  │ │   → 관리자 Alert 발송                                   │   │ │
│  │ └─────────────────────────────────────────────────────────┘   │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 동작 방식

### 1. 정상 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [정상 처리]                                                          │
│                                                                     │
│  Job1 ──→ 처리 성공 ──→ DONE                                        │
│  Job2 ──→ 처리 성공 ──→ DONE                                        │
│  Job3 ──→ 처리 성공 ──→ DONE                                        │
│                                                                     │
│  ※ 순차 처리 (concurrency: 1)                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2. 실패 시 큐 정지 플로우

```
┌─────────────────────────────────────────────────────────────────────┐
│  [실패 시 큐 정지]                                                    │
│                                                                     │
│  Job1 ──→ 1차 실패 ──→ 5초 대기 ──→ 재시도                          │
│       ──→ 2차 실패 ──→ 10초 대기 ──→ 재시도                         │
│       ──→ 3차 실패 ──→ ★최종 실패★                                  │
│                      │                                              │
│                      ├─→ sync_events.status = FAILED                │
│                      ├─→ availabilityStatus = ERROR                 │
│                      ├─→ ★nasQueue.pause()★ ← 큐 일시정지           │
│                      └─→ Alert: "NAS 동기화 실패, 큐 정지됨"         │
│                                                                     │
│  Job2 ──→ 대기 (큐가 멈춰있음)                                       │
│  Job3 ──→ 대기                                                      │
│  Job4 ──→ 대기                                                      │
│           ...                                                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 3. 관리자 개입 후 큐 재개

```
┌─────────────────────────────────────────────────────────────────────┐
│  [관리자 개입 후 재개]                                                │
│                                                                     │
│  관리자:                                                             │
│    1. Alert 수신                                                    │
│    2. GET /admin/queue/status → 큐 상태 확인                        │
│    3. GET /admin/queue/failed/:jobId → 실패 원인 확인               │
│    4. 원인 해결 (NAS 복구, 수동 파일 처리 등)                        │
│    5. POST /admin/queue/skip/:jobId 또는 retry/:jobId               │
│    6. POST /admin/queue/resume ← ★큐 재개★                         │
│                                                                     │
│  Job2 ──→ 처리 재개 ──→ DONE                                        │
│  Job3 ──→ 처리 ──→ DONE                                             │
│  Job4 ──→ 처리 ──→ DONE                                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## sync_events 상태 정의

| 상태 | 설명 | 다음 상태 |
|------|------|----------|
| **PENDING** | Bull 큐 등록됨, 처리 대기 | PROCESSING |
| **PROCESSING** | Bull Worker가 처리 중 | DONE / (재시도) / FAILED |
| **DONE** | 처리 성공 완료 | - (최종) |
| **FAILED** | 최종 실패 (3회 재시도 소진, 큐 정지됨) | MANUALLY_RESOLVED |
| **MANUALLY_RESOLVED** | 관리자가 수동 처리 완료 | - (최종) |

```
┌─────────────────────────────────────────────────────────────────────┐
│  [상태 전이 다이어그램]                                               │
│                                                                     │
│  ┌──────────┐                                                       │
│  │ PENDING  │ ← 트랜잭션 커밋 시 생성                               │
│  └────┬─────┘                                                       │
│       │ Bull Worker 시작                                            │
│       ▼                                                             │
│  ┌──────────┐                                                       │
│  │PROCESSING│                                                       │
│  └────┬─────┘                                                       │
│       │                                                             │
│       ├─────────── 성공 ───────────────→ ┌──────────┐               │
│       │                                  │   DONE   │               │
│       │                                  └──────────┘               │
│       │                                                             │
│       ├─────────── 실패 (1~2회) ────────→ 자동 재시도               │
│       │                                                             │
│       └─────────── 실패 (3회) ─────────→ ┌──────────┐               │
│                                          │  FAILED  │               │
│                                          │ +큐 정지 │               │
│                                          └────┬─────┘               │
│                                               │ 관리자 처리         │
│                                               ▼                     │
│                                          ┌──────────────────┐       │
│                                          │MANUALLY_RESOLVED │       │
│                                          └──────────────────┘       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 관리자 API

### 1. 큐 상태 조회

```
GET /admin/queue/status

Response:
{
  "isPaused": true,              // 큐 일시정지 여부
  "waiting": 15,                 // 대기 중인 작업 수
  "active": 0,                   // 처리 중인 작업 수
  "failed": 1,                   // 실패한 작업 수
  "completed": 142,              // 완료된 작업 수
  "delayed": 0,                  // 지연된 작업 수
  "pausedAt": "2026-01-20T10:30:00Z",  // 정지 시각
  "pauseReason": "NAS_SYNC_FAILED"     // 정지 사유
}
```

### 2. 실패한 작업 목록 조회

```
GET /admin/queue/failed?page=1&limit=10

Response:
{
  "total": 1,
  "items": [
    {
      "jobId": "123",
      "syncEventId": "uuid-xxx",
      "aggregateType": "FILE",
      "aggregateId": "file-uuid",
      "eventType": "NAS_SYNC_UPLOAD",
      "failedReason": "ECONNREFUSED: NAS connection refused",
      "attemptsMade": 3,
      "failedAt": "2026-01-20T10:30:00Z",
      "data": {
        "nasPath": "/project/docs/file.pdf",
        "fileName": "file.pdf"
      }
    }
  ]
}
```

### 3. 실패한 작업 상세 조회

```
GET /admin/queue/failed/:jobId

Response:
{
  "jobId": "123",
  "syncEventId": "uuid-xxx",
  "aggregateType": "FILE",
  "aggregateId": "file-uuid",
  "eventType": "NAS_SYNC_UPLOAD",
  "payload": {
    "nasPath": "/project/docs/file.pdf",
    "fileName": "file.pdf",
    "size": 1048576,
    "mimeType": "application/pdf"
  },
  "failedReason": "ECONNREFUSED: NAS connection refused",
  "stackTrace": "Error: connect ECONNREFUSED 192.168.1.100:445...",
  "attemptsMade": 3,
  "attempts": [
    { "attemptNumber": 1, "error": "ECONNREFUSED", "timestamp": "..." },
    { "attemptNumber": 2, "error": "ECONNREFUSED", "timestamp": "..." },
    { "attemptNumber": 3, "error": "ECONNREFUSED", "timestamp": "..." }
  ],
  "createdAt": "2026-01-20T10:25:00Z",
  "failedAt": "2026-01-20T10:30:00Z"
}
```

### 4. 큐 재개

```
POST /admin/queue/resume

Response:
{
  "success": true,
  "message": "큐가 재개되었습니다.",
  "pendingJobs": 15,
  "resumedAt": "2026-01-20T11:00:00Z"
}
```

### 5. 실패한 작업 재시도

```
POST /admin/queue/retry/:jobId

Response:
{
  "success": true,
  "message": "작업이 재시도 큐에 추가되었습니다.",
  "jobId": "123",
  "newJobId": "124"
}
```

### 6. 실패한 작업 건너뛰기 (수동 처리 완료)

```
POST /admin/queue/skip/:jobId
Body: {
  "reason": "NAS에 직접 파일 복사 완료",    // 수동 처리 사유 (필수)
  "resolvedBy": "admin-user-id"             // 처리자 (자동 입력)
}

Response:
{
  "success": true,
  "message": "작업이 수동 처리 완료로 표시되었습니다.",
  "jobId": "123",
  "syncEventId": "uuid-xxx",
  "newStatus": "MANUALLY_RESOLVED"
}
```

### 7. 모든 실패 작업 건너뛰고 큐 재개

```
POST /admin/queue/skip-all-and-resume
Body: {
  "reason": "NAS 장애 복구 완료, 모든 작업 수동 처리됨"
}

Response:
{
  "success": true,
  "skippedCount": 3,
  "message": "3개의 실패 작업이 건너뛰어지고 큐가 재개되었습니다.",
  "resumedAt": "2026-01-20T11:00:00Z"
}
```

### 8. 큐 강제 일시정지 (수동)

```
POST /admin/queue/pause
Body: {
  "reason": "NAS 점검 예정"
}

Response:
{
  "success": true,
  "message": "큐가 일시정지되었습니다.",
  "pausedAt": "2026-01-20T11:00:00Z"
}
```

---

## 관리자 처리 워크플로우

### Case A: NAS 일시 장애 (복구 후 재시도)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [시나리오: NAS 서버 일시 장애]                                       │
│                                                                     │
│  1. Alert 수신: "NAS 동기화 실패, 큐 정지됨"                         │
│                                                                     │
│  2. 원인 파악                                                        │
│     GET /admin/queue/failed/123                                     │
│     → failedReason: "ECONNREFUSED: NAS connection refused"          │
│                                                                     │
│  3. NAS 서버 상태 확인                                               │
│     → NAS 서버 재시작 또는 네트워크 복구                             │
│                                                                     │
│  4. NAS 정상 확인 후 재시도                                          │
│     POST /admin/queue/retry/123                                     │
│                                                                     │
│  5. 큐 재개                                                          │
│     POST /admin/queue/resume                                        │
│                                                                     │
│  6. 모니터링                                                         │
│     GET /admin/queue/status → isPaused: false 확인                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Case B: 특정 파일 문제 (수동 처리)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [시나리오: 특정 파일 경로 문제]                                      │
│                                                                     │
│  1. Alert 수신: "NAS 동기화 실패, 큐 정지됨"                         │
│                                                                     │
│  2. 원인 파악                                                        │
│     GET /admin/queue/failed/123                                     │
│     → failedReason: "EACCES: permission denied, '/restricted/...'"  │
│                                                                     │
│  3. 수동 처리                                                        │
│     → NAS에 직접 접속하여 파일 복사/권한 수정                        │
│     → 또는 대상 경로 변경 후 DB 수동 업데이트                        │
│                                                                     │
│  4. 작업 건너뛰기                                                    │
│     POST /admin/queue/skip/123                                      │
│     Body: { "reason": "NAS에 직접 파일 복사 완료" }                  │
│                                                                     │
│  5. 큐 재개                                                          │
│     POST /admin/queue/resume                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Case C: 다수 실패 일괄 처리

```
┌─────────────────────────────────────────────────────────────────────┐
│  [시나리오: NAS 장시간 장애 후 복구]                                  │
│                                                                     │
│  1. Alert 수신 (여러 건)                                             │
│                                                                     │
│  2. 상태 확인                                                        │
│     GET /admin/queue/status                                         │
│     → failed: 25, waiting: 150                                      │
│                                                                     │
│  3. NAS 장애 복구 확인                                               │
│                                                                     │
│  4-A. 모든 실패 작업 재시도 원하는 경우                              │
│       → 실패 작업들을 하나씩 retry                                   │
│       → POST /admin/queue/resume                                    │
│                                                                     │
│  4-B. 모든 실패 작업 건너뛰기 원하는 경우                            │
│       → 수동으로 NAS에 파일들 복사 완료 후                           │
│       → POST /admin/queue/skip-all-and-resume                       │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 구현 코드 예시

### Bull Worker - 실패 시 큐 정지

```typescript
// nas-sync.processor.ts
import { Process, Processor, OnQueueFailed } from '@nestjs/bull';
import { InjectQueue } from '@nestjs/bull';
import { Queue, Job } from 'bull';

@Processor('nas-sync')
export class NasSyncProcessor {
  constructor(
    @InjectQueue('nas-sync') private nasQueue: Queue,
    private syncEventService: SyncEventService,
    private storageObjectService: StorageObjectService,
    private alertService: AlertService,
  ) {}

  @Process('sync')
  async handleSync(job: Job) {
    const { syncEventId, aggregateType, aggregateId, eventType, payload } = job.data;
    
    // 상태를 PROCESSING으로 업데이트
    await this.syncEventService.updateStatus(syncEventId, 'PROCESSING');
    
    // NAS 작업 수행
    await this.nasService.performSync(eventType, payload);
    
    // 성공 시 상태 업데이트
    await this.syncEventService.updateStatus(syncEventId, 'DONE');
    await this.storageObjectService.updateAvailability(aggregateId, aggregateType, 'AVAILABLE');
  }

  @OnQueueFailed()
  async onFailed(job: Job, error: Error) {
    const { syncEventId, aggregateType, aggregateId } = job.data;
    
    if (job.attemptsMade >= 3) {
      // 1. sync_events 상태 업데이트
      await this.syncEventService.update(syncEventId, {
        status: 'FAILED',
        attemptCount: job.attemptsMade,
        lastError: error.message,
      });
      
      // 2. storage_objects 상태 업데이트
      await this.storageObjectService.updateAvailability(
        aggregateId, 
        aggregateType, 
        'ERROR'
      );
      
      // 3. ★큐 일시정지★
      await this.nasQueue.pause();
      
      // 4. 큐 정지 메타데이터 저장 (Redis)
      await this.queueMetaService.setPauseInfo({
        pausedAt: new Date(),
        reason: 'NAS_SYNC_FAILED',
        failedJobId: job.id,
        failedSyncEventId: syncEventId,
      });
      
      // 5. 관리자 알림
      await this.alertService.sendCriticalAlert({
        type: 'NAS_SYNC_FAILED_QUEUE_PAUSED',
        severity: 'CRITICAL',
        title: 'NAS 동기화 실패 - 큐 일시정지됨',
        message: `NAS 동기화가 3회 실패하여 큐가 일시정지되었습니다.
                  수동 처리 후 큐 재개가 필요합니다.`,
        details: {
          jobId: job.id,
          syncEventId,
          aggregateType,
          aggregateId,
          eventType: job.data.eventType,
          error: error.message,
          pendingJobCount: await this.nasQueue.getWaitingCount(),
        },
      });
    }
  }
}
```

### 관리자 컨트롤러

```typescript
// admin-queue.controller.ts
import { Controller, Get, Post, Param, Body, UseGuards } from '@nestjs/common';
import { InjectQueue } from '@nestjs/bull';
import { Queue } from 'bull';
import { AdminGuard } from '../guards/admin.guard';

@Controller('admin/queue')
@UseGuards(AdminGuard)
export class AdminQueueController {
  constructor(
    @InjectQueue('nas-sync') private nasQueue: Queue,
    private syncEventService: SyncEventService,
    private queueMetaService: QueueMetaService,
  ) {}

  @Get('status')
  async getQueueStatus() {
    const pauseInfo = await this.queueMetaService.getPauseInfo();
    
    return {
      isPaused: await this.nasQueue.isPaused(),
      waiting: await this.nasQueue.getWaitingCount(),
      active: await this.nasQueue.getActiveCount(),
      failed: await this.nasQueue.getFailedCount(),
      completed: await this.nasQueue.getCompletedCount(),
      delayed: await this.nasQueue.getDelayedCount(),
      pausedAt: pauseInfo?.pausedAt,
      pauseReason: pauseInfo?.reason,
    };
  }

  @Get('failed')
  async getFailedJobs(@Query('page') page = 1, @Query('limit') limit = 10) {
    const start = (page - 1) * limit;
    const failedJobs = await this.nasQueue.getFailed(start, start + limit - 1);
    
    return {
      total: await this.nasQueue.getFailedCount(),
      items: failedJobs.map(job => ({
        jobId: job.id,
        syncEventId: job.data.syncEventId,
        aggregateType: job.data.aggregateType,
        aggregateId: job.data.aggregateId,
        eventType: job.data.eventType,
        failedReason: job.failedReason,
        attemptsMade: job.attemptsMade,
        failedAt: new Date(job.finishedOn),
        data: job.data.payload,
      })),
    };
  }

  @Post('resume')
  async resumeQueue() {
    await this.nasQueue.resume();
    await this.queueMetaService.clearPauseInfo();
    
    return {
      success: true,
      message: '큐가 재개되었습니다.',
      pendingJobs: await this.nasQueue.getWaitingCount(),
      resumedAt: new Date(),
    };
  }

  @Post('retry/:jobId')
  async retryJob(@Param('jobId') jobId: string) {
    const job = await this.nasQueue.getJob(jobId);
    if (!job) {
      throw new NotFoundException('작업을 찾을 수 없습니다.');
    }
    
    // 실패한 작업 재시도
    const newJob = await this.nasQueue.add('sync', job.data, {
      attempts: 3,
      backoff: { type: 'exponential', delay: 5000 },
    });
    
    // 기존 실패 작업 제거
    await job.remove();
    
    // sync_events 상태 업데이트
    await this.syncEventService.updateStatus(job.data.syncEventId, 'PENDING');
    
    return {
      success: true,
      message: '작업이 재시도 큐에 추가되었습니다.',
      jobId,
      newJobId: newJob.id,
    };
  }

  @Post('skip/:jobId')
  async skipJob(
    @Param('jobId') jobId: string,
    @Body() body: { reason: string },
    @CurrentUser() user: User,
  ) {
    const job = await this.nasQueue.getJob(jobId);
    if (!job) {
      throw new NotFoundException('작업을 찾을 수 없습니다.');
    }
    
    // sync_events 상태를 MANUALLY_RESOLVED로 업데이트
    await this.syncEventService.update(job.data.syncEventId, {
      status: 'MANUALLY_RESOLVED',
      resolvedBy: user.id,
      resolvedAt: new Date(),
      resolutionNote: body.reason,
    });
    
    // 실패한 작업 제거
    await job.remove();
    
    return {
      success: true,
      message: '작업이 수동 처리 완료로 표시되었습니다.',
      jobId,
      syncEventId: job.data.syncEventId,
      newStatus: 'MANUALLY_RESOLVED',
    };
  }

  @Post('skip-all-and-resume')
  async skipAllAndResume(@Body() body: { reason: string }, @CurrentUser() user: User) {
    const failedJobs = await this.nasQueue.getFailed();
    
    for (const job of failedJobs) {
      await this.syncEventService.update(job.data.syncEventId, {
        status: 'MANUALLY_RESOLVED',
        resolvedBy: user.id,
        resolvedAt: new Date(),
        resolutionNote: body.reason,
      });
      await job.remove();
    }
    
    await this.nasQueue.resume();
    await this.queueMetaService.clearPauseInfo();
    
    return {
      success: true,
      skippedCount: failedJobs.length,
      message: `${failedJobs.length}개의 실패 작업이 건너뛰어지고 큐가 재개되었습니다.`,
      resumedAt: new Date(),
    };
  }

  @Post('pause')
  async pauseQueue(@Body() body: { reason: string }) {
    await this.nasQueue.pause();
    await this.queueMetaService.setPauseInfo({
      pausedAt: new Date(),
      reason: body.reason || 'MANUAL_PAUSE',
    });
    
    return {
      success: true,
      message: '큐가 일시정지되었습니다.',
      pausedAt: new Date(),
    };
  }
}
```

---

## Bull Queue 설정

```typescript
// nas-sync.module.ts
import { BullModule } from '@nestjs/bull';

@Module({
  imports: [
    BullModule.registerQueue({
      name: 'nas-sync',
      defaultJobOptions: {
        attempts: 3,                          // 최대 3회 재시도
        backoff: {
          type: 'exponential',
          delay: 5000,                        // 5초, 10초, 20초
        },
        removeOnComplete: true,               // 성공 시 제거
        removeOnFail: false,                  // 실패 시 유지 (분석용)
      },
      settings: {
        lockDuration: 60000,                  // 작업 락 1분
        stalledInterval: 30000,               // 정체 확인 30초
        maxStalledCount: 1,                   // 정체 시 재시도 1회
      },
      limiter: {
        max: 1,                               // 동시 처리 1개 (순차 처리)
        duration: 1000,
      },
    }),
  ],
})
export class NasSyncModule {}
```

---

## 모니터링 및 알림

### Alert 유형

| Alert 유형 | 심각도 | 트리거 조건 | 필요 조치 |
|-----------|--------|------------|----------|
| `NAS_SYNC_FAILED_QUEUE_PAUSED` | CRITICAL | 3회 재시도 실패 | 즉시 확인 필요 |
| `QUEUE_WAITING_EXCEEDED` | WARNING | 대기 작업 > 100개 | 처리 속도 확인 |
| `QUEUE_PAUSED_LONG_TIME` | WARNING | 정지 후 1시간 경과 | 조치 필요 |

### 대시보드 메트릭

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Queue Dashboard]                                                  │
│                                                                     │
│  상태: 🔴 일시정지됨 (PAUSED)                                          │ 
│  정지 시각: 2026-01-20 10:30:00 (30분 전)                              │
│  정지 사유: NAS_SYNC_FAILED                                           │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ 대기: 15 │ 활성: 0 │ 실패: 1 │ 완료: 142 │ 지연: 0          │   │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  [실패한 작업]                                                        │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │ #123 │ FILE │ NAS_SYNC_UPLOAD │ ECONNREFUSED │ 10:30:00     │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                                                                     │
│  [액션]                                                              │
│  [ 재시도 ] [ 건너뛰기 ] [ 큐 재개 ]                                     │    
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 주의사항

| 항목 | 설명 |
|------|------|
| **순차 처리** | `concurrency: 1`로 설정하여 순차 처리 보장 |
| **큐 정지 범위** | 전체 큐 정지 (모든 파일/폴더 작업 대기) |
| **재개 권한** | 관리자만 큐 재개 가능 (AdminGuard) |
| **실패 작업 보존** | `removeOnFail: false`로 분석용 보존 |
| **타임아웃** | 작업별 타임아웃 설정 권장 (기본 30초) |
| **정체 감지** | `stalledInterval`로 정체된 작업 감지 |

---

## 요약

| 핵심 원칙 | 설명 |
|----------|------|
| **실패 시 정지** | 3회 재시도 실패 → 큐 자동 일시정지 |
| **수동 해제** | 관리자가 원인 파악 후 명시적 재개 |
| **연쇄 실패 방지** | NAS 장애 시 후속 작업 실패 방지 |
| **추적성** | sync_events로 모든 작업 상태 추적 |
| **순차 처리** | 파일 순서 의존성 보장 (동시성 1) |
