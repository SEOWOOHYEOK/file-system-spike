# 005-3. 파일 단위 큐 NAS 동기화

파일(문서) 단위로 큐를 관리하여 NAS 동기화를 처리하는 방식의 시퀀스 다이어그램

---

## 개요

### 기존 방식 vs 파일 단위 큐 방식

```
기존 방식 (작업 레벨):
  sync_events: [MOVE(a,1→2), DELETE(a,2), MOVE(b,1→3)]
  → 순서 보장 어려움, 락 경합 발생 가능

파일 단위 큐 방식:
  queue(fileId=a): MOVE(1→2) → DELETE
  queue(fileId=b): MOVE(1→3)
  → 파일별 순차 처리, 파일 간 병렬 처리
```

---

## 1. 기본 구조

### 1-1. 파일 단위 큐 아키텍처

```mermaid
flowchart TB
    subgraph API["API Server"]
        A[파일 작업 요청]
    end
    
    subgraph QueueSystem["Queue System"]
        direction TB
        QM[Queue Manager]
        subgraph FileQueues["File-specific Queues"]
            Q1["queue(fileId=a)<br/>MOVE → DELETE"]
            Q2["queue(fileId=b)<br/>RENAME"]
            Q3["queue(fileId=c)<br/>UPLOAD"]
        end
    end
    
    subgraph Workers["Worker Pool"]
        W1[Worker 1]
        W2[Worker 2]
        W3[Worker 3]
    end
    
    subgraph Storage["Storage"]
        NAS[(NAS)]
    end
    
    A --> QM
    QM --> Q1
    QM --> Q2
    QM --> Q3
    Q1 --> W1
    Q2 --> W2
    Q3 --> W3
    W1 --> NAS
    W2 --> NAS
    W3 --> NAS
```

---

## 2. 단일 파일 작업

### 2-1. 파일 업로드 → NAS 동기화

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant Cache as SeaweedFS
    participant DB as PostgreSQL
    participant QM as Queue Manager
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant NAS as NAS

    User->>API: POST /files/upload (file, folderId)
    
    API->>Cache: 1. save file to cache
    Cache-->>API: OK
    
    API->>DB: 2. BEGIN TRANSACTION
    API->>DB: INSERT files (id=a, state=ACTIVE)
    API->>DB: INSERT file_storage_objects (CACHE, AVAILABLE)
    API->>DB: INSERT file_storage_objects (NAS, PENDING)
    API->>DB: INSERT file_sync_queue (fileId=a, operation=UPLOAD, seq=1)
    API->>DB: COMMIT
    
    API-->>User: 200 OK (fileId=a)
    
    Note over QM,FQ: Queue Manager (Scheduler)
    QM->>DB: SELECT DISTINCT fileId FROM file_sync_queue<br/>WHERE status=PENDING GROUP BY fileId
    QM->>FQ: getOrCreate queue for fileId=a
    QM->>FQ: enqueue UPLOAD operation
    
    Note over FQ,Worker: 파일별 순차 처리
    FQ->>Worker: process UPLOAD (fileId=a)
    Worker->>DB: SELECT operation details
    Worker->>Cache: get file stream
    Worker->>NAS: upload file
    NAS-->>Worker: OK
    
    Worker->>DB: BEGIN
    Worker->>DB: UPDATE file_storage_objects (NAS, AVAILABLE)
    Worker->>DB: UPDATE file_sync_queue (status=DONE)
    Worker->>DB: COMMIT
    
    Worker-->>FQ: operation complete
    FQ->>FQ: check next operation (none)
    FQ->>QM: queue empty, cleanup
```

---

### 2-2. 파일 이름 변경

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant QM as Queue Manager
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant NAS as NAS

    User->>API: PUT /files/a/rename (newName)
    
    API->>DB: 1. BEGIN TRANSACTION
    API->>DB: SELECT * FROM files WHERE id=a FOR UPDATE
    DB-->>API: file info (oldName, path)
    
    API->>DB: 2. check duplicate filename
    DB-->>API: no duplicate
    
    API->>DB: 3. UPDATE files SET name=newName
    API->>DB: 4. INSERT file_sync_queue (fileId=a, operation=RENAME, seq=next, metadata={oldPath, newPath})
    API->>DB: COMMIT
    
    API-->>User: 200 OK (id=a, name=newName)
    
    Note over QM,FQ: Queue Manager
    QM->>FQ: enqueue RENAME for fileId=a
    
    Note over FQ,Worker: Worker 처리
    FQ->>Worker: process RENAME
    Worker->>DB: get operation details (oldPath, newPath)
    Worker->>NAS: rename file (oldPath → newPath)
    NAS-->>Worker: OK
    
    Worker->>DB: UPDATE file_sync_queue (status=DONE)
    Worker-->>FQ: complete
```

---

## 3. 연속 작업 (핵심 케이스)

### 3-1. 이동 → 삭제 (Move then Delete)

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant QM as Queue Manager
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant NAS as NAS

    Note over User,API: 1단계: 파일 이동 요청
    User->>API: POST /files/a/move (targetFolderId=2)
    
    API->>DB: BEGIN TRANSACTION
    API->>DB: UPDATE files SET folderId=2
    API->>DB: INSERT file_sync_queue (fileId=a, op=MOVE, seq=1)
    API->>DB: COMMIT
    
    API-->>User: 200 OK (syncQueueId=101)
    
    Note over User,API: 2단계: 바로 삭제 요청 (이동 완료 전)
    User->>API: DELETE /files/a
    
    API->>DB: BEGIN TRANSACTION
    API->>DB: UPDATE files SET state=TRASHED
    API->>DB: INSERT file_sync_queue (fileId=a, op=TRASH, seq=2)
    API->>DB: COMMIT
    
    API-->>User: 200 OK (syncQueueId=102)
    
    Note over QM,FQ: Queue Manager - 파일별 큐 생성
    QM->>DB: SELECT * FROM file_sync_queue<br/>WHERE fileId=a ORDER BY seq
    DB-->>QM: [MOVE(seq=1), TRASH(seq=2)]
    QM->>FQ: create queue with ordered operations
    
    Note over FQ,NAS: 순차 처리 보장
    rect rgb(57, 59, 57)
        Note over FQ,NAS: Operation 1: MOVE
        FQ->>Worker: process MOVE (seq=1)
        Worker->>NAS: move file (folder1 → folder2)
        NAS-->>Worker: OK
        Worker->>DB: UPDATE file_sync_queue SET status=DONE WHERE seq=1
        Worker-->>FQ: MOVE complete
    end
    
    rect rgb(57, 59, 57)
        Note over FQ,NAS: Operation 2: TRASH (이전 작업 완료 후)
        FQ->>Worker: process TRASH (seq=2)
        Worker->>NAS: move file to .trash/ (from folder2!)
        NAS-->>Worker: OK
        Worker->>DB: UPDATE file_sync_queue SET status=DONE WHERE seq=2
        Worker-->>FQ: TRASH complete
    end
    
    FQ->>QM: all operations done, cleanup queue
```

---

### 3-2. 업로드 → 이름변경 → 이동 (연속 3개 작업)

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant NAS as NAS

    Note over User,DB: 빠른 연속 요청
    User->>API: POST /files/upload
    API->>DB: INSERT file_sync_queue (op=UPLOAD, seq=1)
    API-->>User: 200 OK
    
    User->>API: PUT /files/a/rename
    API->>DB: INSERT file_sync_queue (op=RENAME, seq=2)
    API-->>User: 200 OK
    
    User->>API: POST /files/a/move
    API->>DB: INSERT file_sync_queue (op=MOVE, seq=3)
    API-->>User: 200 OK
    
    Note over FQ,NAS: 파일 큐 - 순차 처리
    
    rect rgb(57, 59, 57)
        Note over FQ,NAS: Step 1: UPLOAD
        FQ->>Worker: process UPLOAD
        Worker->>NAS: upload to /folder1/fileA.txt
        NAS-->>Worker: OK
        Worker-->>FQ: done
    end
    
    rect rgb(57, 59, 57)
        Note over FQ,NAS: Step 2: RENAME (UPLOAD 완료 후)
        FQ->>Worker: process RENAME
        Worker->>NAS: rename fileA.txt → fileB.txt
        NAS-->>Worker: OK
        Worker-->>FQ: done
    end
    
    rect rgb(57, 59, 57)
        Note over FQ,NAS: Step 3: MOVE (RENAME 완료 후)
        FQ->>Worker: process MOVE
        Worker->>NAS: move /folder1/fileB.txt → /folder2/fileB.txt
        NAS-->>Worker: OK
        Worker-->>FQ: done
    end
```

---

## 4. 병렬 처리 (다중 파일)

### 4-1. 서로 다른 파일 동시 처리

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant QM as Queue Manager
    participant FQa as FileQueue(a)
    participant FQb as FileQueue(b)
    participant FQc as FileQueue(c)
    participant W1 as Worker 1
    participant W2 as Worker 2
    participant W3 as Worker 3
    participant NAS as NAS

    Note over User,API: 동시에 여러 파일 작업 요청
    par 병렬 요청
        User->>API: MOVE file a
        API->>DB: INSERT queue (fileId=a, MOVE)
    and
        User->>API: DELETE file b
        API->>DB: INSERT queue (fileId=b, DELETE)
    and
        User->>API: RENAME file c
        API->>DB: INSERT queue (fileId=c, RENAME)
    end
    
    Note over QM,FQc: Queue Manager - 파일별 큐 분배
    QM->>FQa: enqueue MOVE
    QM->>FQb: enqueue DELETE
    QM->>FQc: enqueue RENAME
    
    Note over W1,NAS: 완전 병렬 처리 (파일 간 독립)
    par 병렬 실행
        FQa->>W1: process MOVE(a)
        W1->>NAS: move file a
        NAS-->>W1: OK
    and
        FQb->>W2: process DELETE(b)
        W2->>NAS: delete file b
        NAS-->>W2: OK
    and
        FQc->>W3: process RENAME(c)
        W3->>NAS: rename file c
        NAS-->>W3: OK
    end
    
    Note over W1,W3: 모든 작업 동시 완료 가능
```

---

### 4-2. 폴더 이동 (하위 파일 일괄 처리)

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant QM as Queue Manager
    participant FQ1 as FileQueue(file1)
    participant FQ2 as FileQueue(file2)
    participant FQ3 as FileQueue(file3)
    participant Workers as Worker Pool
    participant NAS as NAS

    User->>API: POST /folders/folderA/move (targetFolderId=B)
    
    API->>DB: 1. BEGIN TRANSACTION
    API->>DB: UPDATE folders SET parentId=B WHERE id=folderA
    
    API->>DB: 2. SELECT files WHERE folderId IN (folderA subtree)
    DB-->>API: [file1, file2, file3]
    
    loop 각 파일에 대해
        API->>DB: INSERT file_sync_queue (fileId, op=MOVE, metadata)
    end
    API->>DB: COMMIT
    
    API-->>User: 200 OK (affectedFiles: 3)
    
    Note over QM,FQ3: Queue Manager - 파일별 큐 생성
    QM->>FQ1: enqueue MOVE for file1
    QM->>FQ2: enqueue MOVE for file2
    QM->>FQ3: enqueue MOVE for file3
    
    Note over Workers,NAS: 병렬 처리 (각 파일 독립)
    par
        FQ1->>Workers: process file1
        Workers->>NAS: move file1
    and
        FQ2->>Workers: process file2
        Workers->>NAS: move file2
    and
        FQ3->>Workers: process file3
        Workers->>NAS: move file3
    end
    
    NAS-->>Workers: all OK
    Workers->>DB: UPDATE all queues status=DONE
```

---

## 5. 에러 처리

### 5-1. 작업 실패 및 재시도

```mermaid
sequenceDiagram
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant DB as PostgreSQL
    participant NAS as NAS
    participant Alert as Alert System

    Note over FQ,Worker: 큐에 [MOVE, DELETE] 작업 존재
    
    rect rgb(77, 65, 65)
        Note over FQ,NAS: MOVE 작업 - 첫 번째 시도 실패
        FQ->>Worker: process MOVE (attempt=1)
        Worker->>NAS: move file
        NAS-->>Worker: Error (network timeout)
        
        Worker->>DB: UPDATE file_sync_queue<br/>SET retry_count=1, error_message='timeout'
        Worker-->>FQ: retry needed
        
        FQ->>FQ: wait (backoff: 5s)
    end
    
    rect rgb(77, 65, 65)
        Note over FQ,NAS: MOVE 작업 - 두 번째 시도 실패
        FQ->>Worker: process MOVE (attempt=2)
        Worker->>NAS: move file
        NAS-->>Worker: Error (network timeout)
        
        Worker->>DB: UPDATE retry_count=2
        Worker-->>FQ: retry needed
        
        FQ->>FQ: wait (backoff: 10s)
    end
    
    rect rgb(77, 65, 65)
        Note over FQ,NAS: MOVE 작업 - 세 번째 시도 성공
        FQ->>Worker: process MOVE (attempt=3)
        Worker->>NAS: move file
        NAS-->>Worker: OK
        
        Worker->>DB: UPDATE status=DONE, retry_count=0
        Worker-->>FQ: MOVE complete
    end
    
    rect rgb(77, 65, 65)
        Note over FQ,NAS: DELETE 작업 - 이전 성공 후 진행
        FQ->>Worker: process DELETE
        Worker->>NAS: delete file
        NAS-->>Worker: OK
        Worker-->>FQ: DELETE complete
    end
```

---

### 5-2. 최대 재시도 초과 시 처리

```mermaid
sequenceDiagram
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant DB as PostgreSQL
    participant NAS as NAS
    participant Alert as Alert System
    participant Admin as Admin

    Note over FQ,Worker: MOVE 작업 반복 실패
    
    loop 재시도 (max=5)
        FQ->>Worker: process MOVE
        Worker->>NAS: move file
        NAS-->>Worker: Error
        Worker->>DB: UPDATE retry_count++
        Worker-->>FQ: retry
    end
    
    rect rgb(77, 65, 65)
        Note over FQ,Alert: 최대 재시도 초과
        FQ->>Worker: process MOVE (attempt=6)
        Worker->>NAS: move file
        NAS-->>Worker: Error
        
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE file_sync_queue SET status=FAILED
        Worker->>DB: UPDATE file_storage_objects SET availability_status=ERROR
        Worker->>DB: COMMIT
        
        Worker->>Alert: send alert (fileId=a, operation=MOVE, error)
        Alert->>Admin: notification
    end
    
    Note over FQ,DB: 후속 작업 처리 전략
    
    alt 전략 1: 후속 작업 모두 취소
        FQ->>DB: UPDATE file_sync_queue<br/>SET status=CANCELLED<br/>WHERE fileId=a AND seq > failed_seq
        FQ->>FQ: cleanup queue
    else 전략 2: 후속 작업 대기 (수동 개입)
        FQ->>FQ: pause queue
        Admin->>API: POST /admin/sync-queue/a/retry
        API->>FQ: resume from failed operation
    else 전략 3: 후속 작업 건너뛰기
        FQ->>DB: UPDATE SET status=SKIPPED WHERE seq=failed
        FQ->>Worker: process next operation (DELETE)
        Note over Worker: 주의: 이전 상태 기반으로 실행
    end
```

---

## 6. 특수 케이스

### 6-1. 작업 중 새 작업 추가

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant FQ as FileQueue(fileId=a)
    participant Worker as Worker
    participant NAS as NAS

    Note over FQ,Worker: 현재 MOVE 작업 처리 중
    FQ->>Worker: process MOVE
    Worker->>NAS: move file (진행 중...)
    
    Note over User,API: 사용자가 같은 파일에 새 작업 요청
    User->>API: PUT /files/a/rename (newName)
    
    API->>DB: BEGIN
    API->>DB: INSERT file_sync_queue (fileId=a, op=RENAME, seq=2)
    API->>DB: COMMIT
    
    API-->>User: 200 OK (queued, position=2)
    
    Note over Worker,NAS: MOVE 완료
    NAS-->>Worker: OK
    Worker->>DB: UPDATE status=DONE WHERE seq=1
    Worker-->>FQ: complete
    
    Note over FQ,Worker: 큐에서 다음 작업 확인
    FQ->>DB: SELECT next pending operation
    DB-->>FQ: RENAME (seq=2)
    
    FQ->>Worker: process RENAME
    Worker->>NAS: rename file
    NAS-->>Worker: OK
    Worker-->>FQ: complete
```

---

### 6-2. 동일 파일 동시 API 요청 (Race Condition 방지)

```mermaid
sequenceDiagram
    participant U1 as User 1
    participant U2 as User 2
    participant API as API Server
    participant DB as PostgreSQL
    participant FQ as FileQueue(fileId=a)

    par 동시 요청
        U1->>API: POST /files/a/move (to folder2)
    and
        U2->>API: DELETE /files/a
    end
    
    Note over API,DB: DB 레벨에서 순서 결정 (seq 자동 증가)
    
    API->>DB: BEGIN (User1)
    API->>DB: INSERT file_sync_queue (seq=nextval)
    Note over DB: seq = 1 할당
    API->>DB: COMMIT
    
    API->>DB: BEGIN (User2)
    API->>DB: INSERT file_sync_queue (seq=nextval)
    Note over DB: seq = 2 할당
    API->>DB: COMMIT
    
    API-->>U1: 200 OK (queuePosition=1)
    API-->>U2: 200 OK (queuePosition=2)
    
    Note over FQ: 순서대로 처리
    FQ->>FQ: 1. MOVE (folder1 → folder2)
    FQ->>FQ: 2. DELETE (from folder2)
```

---

### 6-3. 큐 상태 조회 API

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant FQ as FileQueue(fileId=a)

    User->>API: GET /files/a/sync-status
    
    API->>DB: SELECT * FROM file_sync_queue<br/>WHERE fileId=a ORDER BY seq
    DB-->>API: queue entries
    
    API->>FQ: get current processing status
    FQ-->>API: processing operation details
    
    API-->>User: 200 OK
    Note over User: Response:
    Note over User: {<br/>  "fileId": "a",<br/>  "queueStatus": "PROCESSING",<br/>  "currentOperation": {<br/>    "type": "MOVE",<br/>    "seq": 1,<br/>    "status": "IN_PROGRESS",<br/>    "startedAt": "...",<br/>    "retryCount": 0<br/>  },<br/>  "pendingOperations": [<br/>    {"type": "RENAME", "seq": 2},<br/>    {"type": "DELETE", "seq": 3}<br/>  ],<br/>  "completedOperations": []<br/>}
```

---

## 7. 데이터 모델

### 7-1. file_sync_queue 테이블 구조

```sql
CREATE TABLE file_sync_queue (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    file_id UUID NOT NULL REFERENCES files(id),
    folder_id UUID REFERENCES folders(id),  -- 폴더 작업용
    
    -- 작업 정보
    operation_type VARCHAR(20) NOT NULL,  -- UPLOAD, MOVE, RENAME, TRASH, DELETE, RESTORE
    seq INTEGER NOT NULL,                  -- 파일별 순서 번호
    
    -- 메타데이터
    metadata JSONB,  -- {sourcePath, targetPath, oldName, newName, etc.}
    
    -- 상태 관리
    status VARCHAR(20) DEFAULT 'PENDING',  -- PENDING, PROCESSING, DONE, FAILED, CANCELLED
    retry_count INTEGER DEFAULT 0,
    max_retries INTEGER DEFAULT 5,
    error_message TEXT,
    
    -- 타임스탬프
    created_at TIMESTAMP DEFAULT NOW(),
    started_at TIMESTAMP,
    completed_at TIMESTAMP,
    
    -- 인덱스용
    UNIQUE(file_id, seq)
);

-- 인덱스
CREATE INDEX idx_sync_queue_file_status ON file_sync_queue(file_id, status);
CREATE INDEX idx_sync_queue_pending ON file_sync_queue(status) WHERE status = 'PENDING';
```

---

## 8. 폴더 삭제 처리

> **정책:** 폴더 안에 파일 또는 하위 폴더가 있는 경우 삭제 불가 (빈 폴더만 삭제 가능)

### 8-1. 폴더 삭제 FLOW

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as PostgreSQL
    participant NAS as NAS

    User->>API: DELETE /folders/{folderId}
    
    API->>DB: 1. BEGIN TRANSACTION
    
    API->>DB: 2. SELECT * FROM folders WHERE id=folderId FOR UPDATE
    DB-->>API: folder info
    
    alt folder not found
        API->>DB: ROLLBACK
        API-->>User: 404 FOLDER_NOT_FOUND
    end
    
    alt folder already TRASHED
        API->>DB: ROLLBACK
        API-->>User: 400 FOLDER_ALREADY_TRASHED
    end
    
    API->>DB: 3. SELECT COUNT(*) FROM files<br/>WHERE folder_id=folderId AND state='ACTIVE'
    DB-->>API: fileCount
    
    API->>DB: 4. SELECT COUNT(*) FROM folders<br/>WHERE parent_id=folderId AND state='ACTIVE'
    DB-->>API: subFolderCount
    
    alt fileCount > 0 OR subFolderCount > 0
        API->>DB: ROLLBACK
        API-->>User: 409 FOLDER_NOT_EMPTY
        Note over User: Response:<br/>{<br/>  "error": "FOLDER_NOT_EMPTY",<br/>  "message": "폴더 안에 파일 또는 하위 폴더가 있어 삭제할 수 없습니다.",<br/>  "details": {<br/>    "fileCount": 3,<br/>    "subFolderCount": 1<br/>  }<br/>}
    end
    
    Note over API,DB: 빈 폴더 확인됨 - 삭제 처리
    
    API->>DB: 5. UPDATE folders SET state='TRASHED', deleted_at=NOW()
    API->>DB: 6. INSERT trash_metadata (folderId, originalPath, expiresAt)
    
    Note over API,NAS: NAS 작업 (트랜잭션 내에서 실행)
    API->>NAS: 7. move empty folder to .trash/{folderId}
    
    alt NAS success
        NAS-->>API: OK
        API->>DB: 8. COMMIT
        API-->>User: 200 OK
        Note over User: Response:<br/>{<br/>  "id": "folderId",<br/>  "name": "folderName",<br/>  "state": "TRASHED",<br/>  "deletedAt": "2026-01-22T10:30:00Z",<br/>  "expiresAt": "2026-02-21T10:30:00Z"<br/>}
    else NAS fail
        NAS-->>API: Error
        API->>DB: 8. ROLLBACK
        API-->>User: 500 NAS_SYNC_FAILED
        Note over User: Response:<br/>{<br/>  "error": "NAS_SYNC_FAILED",<br/>  "message": "NAS 동기화에 실패했습니다. 잠시 후 다시 시도해주세요."<br/>}
    end
```

---

### 8-2. 폴더 삭제 Flowchart

```mermaid
flowchart TD
    A[DELETE /folders/folderId] --> B[BEGIN TRANSACTION]
    B --> C{폴더 존재?}
    C -->|No| D[ROLLBACK]
    D --> E[404 FOLDER_NOT_FOUND]
    C -->|Yes| F{이미 삭제됨?}
    F -->|Yes| G[ROLLBACK]
    G --> H[400 FOLDER_ALREADY_TRASHED]
    F -->|No| I{하위 파일 존재?}
    I -->|Yes| J[ROLLBACK]
    J --> K[409 FOLDER_NOT_EMPTY]
    I -->|No| L{하위 폴더 존재?}
    L -->|Yes| J
    L -->|No| M[빈 폴더 확인]
    M --> N[DB: state='TRASHED']
    N --> O[NAS: move to .trash/]
    O --> P{NAS 성공?}
    P -->|Yes| Q[COMMIT]
    Q --> R[200 OK]
    P -->|No| S[ROLLBACK]
    S --> T[500 NAS_SYNC_FAILED]
    
    style E fill:#000000
    style H fill:#000000
    style K fill:#000000
    style T fill:#000000
    style R fill:#000000
```

---

### 8-3. 에러 응답 정의

| HTTP Status | Error Code | 설명 |
|-------------|------------|------|
| 404 | FOLDER_NOT_FOUND | 폴더가 존재하지 않음 |
| 400 | FOLDER_ALREADY_TRASHED | 이미 휴지통에 있는 폴더 |
| 409 | FOLDER_NOT_EMPTY | 폴더 안에 파일 또는 하위 폴더 존재 |
| 500 | NAS_SYNC_FAILED | NAS 동기화 실패 (재시도 필요) |

**FOLDER_NOT_EMPTY 에러 응답 예시:**

```json
{
  "statusCode": 409,
  "error": "FOLDER_NOT_EMPTY",
  "message": "폴더 안에 파일 또는 하위 폴더가 있어 삭제할 수 없습니다. 먼저 내부 항목을 삭제해주세요.",
  "details": {
    "folderId": "uuid-folder-id",
    "folderName": "Documents",
    "fileCount": 5,
    "subFolderCount": 2
  }
}
```

**NAS_SYNC_FAILED 에러 응답 예시:**

```json
{
  "statusCode": 500,
  "error": "NAS_SYNC_FAILED",
  "message": "NAS 동기화에 실패했습니다. 잠시 후 다시 시도해주세요.",
  "details": {
    "folderId": "uuid-folder-id",
    "folderName": "Documents"
  }
}
```

---

### 8-4. 정책 요약

| 케이스 | 처리 결과 |
|--------|----------|
| 빈 폴더 삭제 | ✅ 즉시 삭제 (휴지통 이동) |
| 파일이 있는 폴더 삭제 | ❌ 409 에러 반환 |
| 하위 폴더가 있는 폴더 삭제 | ❌ 409 에러 반환 |
| 파일 + 하위 폴더 모두 있는 폴더 삭제 | ❌ 409 에러 반환 |

**사용자 가이드:**
1. 폴더를 삭제하려면 먼저 내부의 모든 파일과 하위 폴더를 삭제해야 합니다.
2. 재귀적 삭제가 필요한 경우 클라이언트에서 하위 항목부터 순차적으로 삭제 요청을 보내야 합니다.

---

## 9. 장점 요약

| 항목 | 기존 방식 | 파일 단위 큐 |
|------|----------|-------------|
| 순서 보장 | △ (락 필요) | ◎ (자동) |
| 동시성 안전 | △ (충돌 가능) | ◎ (원천 차단) |
| 병렬 처리 | △ (제한적) | ◎ (파일 간 완전 병렬) |
| 에러 추적 | △ | ◎ (파일별 상태) |
| 복잡도 | ○ | △ (큐 관리 필요) |

---

## 10. 참고

- [005-1.파일_처리_FLOW.md](./005-1.파일_처리_FLOW.md) - 기존 파일 처리 FLOW
- [005-2.파일명중복전략.md](./005-2.파일명중복전략.md) - 파일명 중복 처리 전략
- [050.큐관리.md](./050.큐관리.md) - Bull 큐 관리
