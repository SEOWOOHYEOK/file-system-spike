# 005. 파일 관리 API

---

## 개요

파일 업로드, 다운로드, 이름 변경, 삭제, 이동 등 파일 관련 API의 상세 플로우를 정의합니다.

**참고 문서**
- [001.정의.md](./001.정의.md) - 공통 사항 (로깅, 동시성 제어, NAS 동기화)
- [0011.엔티티.md](./0011.엔티티.md) - 엔티티 정의

---

## API 엔드포인트 목록

| Method | Endpoint | 설명 |
|--------|----------|------|
| POST | /files/upload | 일반 파일 업로드 (100MB 미만) |

| POST | /files/multipart/initiate | 멀티파트 업로드 초기화 |
| PUT | /files/multipart/{sessionId}/parts/{partNumber} | 파트 업로드 |
| POST | /files/multipart/{sessionId}/complete | 멀티파트 업로드 완료 |
| GET | /files/multipart/{sessionId}/status | 멀티파트 세션 상태 조회 |
| DELETE | /files/multipart/{sessionId} | 멀티파트 업로드 취소 |

| GET | /files/{fileId} | 파일 정보 조회 |
| GET | /files/{fileId}/download | 파일 다운로드 |
| PUT | /files/{fileId}/rename | 파일명 변경 |
| POST | /files/{fileId}/move | 파일 이동 |

| DELETE | /files/{fileId} | 파일 삭제 (휴지통) |

---

# 1. 파일 업로드

## 1-1. POST /files/upload - 일반 업로드 (100MB 미만)

### Request

```typescript
// Content-Type: multipart/form-data
interface UploadFileRequest {
  file: File;                       // 업로드할 파일
  folderId: string;                 // 대상 폴더 ID
  conflictStrategy?: 'ERROR' | 'RENAME';  // 기본값: ERROR
}
```

### Response

```typescript
interface UploadFileResponse {
  id: string;
  name: string;
  folderId: string;
  path: string;
  size: number;
  mimeType: string;
  storageStatus: {
    cache: 'AVAILABLE';
    nas: 'SYNCING';
  };
  createdAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [POST /files/upload 처리 플로우]                                         │
│                                                                         │
│  1. 요청 검증                                                            │
│     ├─ 파일 크기 체크 (100MB 미만)                                       │
│     ├─ 파일 타입 검증                                                    │
│     └─ 폴더 존재 확인                                                    │
│                                                                         │
│  2. 동일 파일명 체크                                                     │
│     ├─ 같은 폴더 내 동일 name + mimeType 존재 확인                       │
│     ├─ 충돌 시 conflictStrategy에 따라 처리                              │
│     │   ├─ ERROR: 409 Conflict 반환                                     │
│     │   └─ RENAME: 자동 이름 변경 "file (1).txt"                        │
│     └─ 통과 시 진행                                                      │
│                                                                         │
│  3. UUID 미리 생성                                                       │
│     └─ fileId = uuid.v4()                                               │
│                                                                         │
│  4. ★SeaweedFS 저장 먼저★                                               │
│     ├─ objectKey = fileId                                               │
│     ├─ 실패 시 → 즉시 에러 반환 (DB 변경 없음)                          │
│     └─ 성공 시 → 다음 단계                                              │
│                                                                         │
│  5. ★DB 트랜잭션★                                                       │
│     ├─ INSERT files (id=fileId, state=ACTIVE)                           │
│     ├─ INSERT file_storage_objects (CACHE, AVAILABLE)                   │
│     ├─ INSERT file_storage_objects (NAS, SYNCING)                       │
│     ├─ INSERT file_events (UPLOAD)                                      │
│     ├─ 실패 시 → DB 롤백 + SeaweedFS 삭제 (보상)                        │
│     └─ 성공 시 → COMMIT                                                 │
│                                                                         │
│  6. Bull 큐 등록                                                         │
│     └─ NAS_SYNC_UPLOAD 작업 등록 (3회 재시도)                           │
│                                                                         │
│  7. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 폴더 존재 확인
SELECT * FROM folders WHERE id = :folderId AND state = 'ACTIVE';

-- 동일 파일명 체크
SELECT * FROM files 
WHERE folderId = :folderId 
  AND name = :fileName 
  AND mimeType = :mimeType 
  AND state = 'ACTIVE';

-- 파일 생성
INSERT INTO files (id, folderId, name, sizeBytes, mimeType, state, createdAt, updatedAt)
VALUES (:fileId, :folderId, :fileName, :size, :mimeType, 'ACTIVE', NOW(), NOW());

-- 캐시 저장소 객체 생성
INSERT INTO file_storage_objects (
  id, fileId, storageType, objectKey, availabilityStatus, 
  lastAccessed, accessCount, leaseCount, createdAt
) VALUES (
  :id, :fileId, 'CACHE_SEAWEED', :fileId, 'AVAILABLE', 
  NOW(), 1, 0, NOW()
);

-- NAS 저장소 객체 생성 (SYNCING 상태)
INSERT INTO file_storage_objects (
  id, fileId, storageType, objectKey, availabilityStatus, createdAt
) VALUES (
  :id, :fileId, 'NAS', :nasPath, 'SYNCING', NOW()
);

-- 이벤트 기록
INSERT INTO file_events (id, fileId, eventType, traceId, payloadJson, occurredAt)
VALUES (:id, :fileId, 'UPLOAD', :traceId, :payload, NOW());
```

### 에러 처리

| 상황 | HTTP Status | 에러 코드 |
|------|-------------|----------|
| 파일 크기 초과 | 400 | FILE_TOO_LARGE |
| 폴더 없음 | 404 | FOLDER_NOT_FOUND |
| 동일 파일명 존재 | 409 | DUPLICATE_FILE_EXISTS |
| SeaweedFS 저장 실패 | 500 | CACHE_STORAGE_ERROR |
| DB 저장 실패 | 500 | DATABASE_ERROR |

---

## 1-2. POST /files/multipart/initiate - 멀티파트 업로드 초기화

### Request

```typescript
interface InitiateMultipartRequest {
  fileName: string;
  folderId: string;
  totalSize: number;                // bytes
  mimeType: string;
  conflictStrategy?: 'ERROR' | 'RENAME';
}
```

### Response

```typescript
interface InitiateMultipartResponse {
  sessionId: string;
  uploadId: string;                 // SeaweedFS 업로드 ID
  partSize: number;                 // 권장 파트 크기 (bytes)
  totalParts: number;               // 예상 파트 수
  expiresAt: string;                // 세션 만료 시각
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [POST /files/multipart/initiate 처리 플로우]                             │
│                                                                         │
│  1. 요청 검증                                                            │
│     ├─ 파일 크기 체크 (500MB 이상)                                       │
│     └─ 폴더 존재 확인                                                    │
│                                                                         │
│  2. 동일 파일명 체크                                                     │
│     ├─ 충돌 시 conflictStrategy에 따라 처리                              │
│     └─ RENAME 시 최종 파일명 결정                                        │
│                                                                         │
│  3. SeaweedFS 멀티파트 초기화                                            │
│     └─ uploadId 발급                                                     │
│                                                                         │
│  4. DB 트랜잭션                                                          │
│     ├─ INSERT upload_sessions (status=INIT)                             │
│     └─ COMMIT                                                           │
│                                                                         │
│  5. 응답 반환                                                            │
│     └─ sessionId, uploadId, partSize, totalParts                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 세션 생성
INSERT INTO upload_sessions (
  id, traceId, uploaderId, targetFolderId, fileName, mimeType, 
  totalBytes, strategy, status, uploadId, expiresAt, createdAt
) VALUES (
  :sessionId, :traceId, :userId, :folderId, :fileName, :mimeType,
  :totalSize, 'MULTIPART', 'INIT', :uploadId, NOW() + INTERVAL '24 hours', NOW()
);
```

---

## 1-3. PUT /files/multipart/{sessionId}/parts/{partNumber} - 파트 업로드

### Request

```typescript
// Content-Type: application/octet-stream
// Body: 파트 데이터 (binary)
```

### Response

```typescript
interface UploadPartResponse {
  partNumber: number;
  etag: string;
  size: number;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [PUT /files/multipart/{sessionId}/parts/{partNumber} 처리 플로우]        │
│                                                                         │
│  1. 세션 검증                                                            │
│     ├─ 세션 존재 확인                                                    │
│     ├─ 세션 만료 확인 (expiresAt < NOW)                                 │
│     └─ 세션 상태 확인 (INIT 또는 UPLOADING)                             │
│                                                                         │
│  2. SeaweedFS 파트 업로드                                                │
│     └─ uploadId + partNumber로 파트 저장                                │
│                                                                         │
│  3. DB 트랜잭션                                                          │
│     ├─ INSERT upload_parts (etag, bytes, status=COMPLETED)              │
│     ├─ UPDATE upload_sessions SET status='UPLOADING' (첫 파트 시)       │
│     └─ COMMIT                                                           │
│                                                                         │
│  4. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 세션 조회
SELECT * FROM upload_sessions 
WHERE id = :sessionId AND status IN ('INIT', 'UPLOADING') AND expiresAt > NOW();

-- 파트 기록
INSERT INTO upload_parts (id, sessionId, partNumber, bytes, etag, status, createdAt)
VALUES (:id, :sessionId, :partNumber, :bytes, :etag, 'COMPLETED', NOW())
ON CONFLICT (sessionId, partNumber) DO UPDATE SET
  bytes = :bytes, etag = :etag, status = 'COMPLETED', updatedAt = NOW();

-- 세션 상태 업데이트 (첫 파트 시)
UPDATE upload_sessions SET status = 'UPLOADING', updatedAt = NOW()
WHERE id = :sessionId AND status = 'INIT';
```

---

## 1-4. POST /files/multipart/{sessionId}/complete - 멀티파트 완료

### Request

```typescript
interface CompleteMultipartRequest {
  parts: {
    partNumber: number;
    etag: string;
  }[];
}
```

### Response

```typescript
interface CompleteMultipartResponse {
  id: string;                       // 생성된 fileId
  name: string;
  folderId: string;
  path: string;
  size: number;
  mimeType: string;
  storageStatus: {
    cache: 'AVAILABLE';
    nas: 'SYNCING';
  };
  createdAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [POST /files/multipart/{sessionId}/complete 처리 플로우]                 │
│                                                                         │
│  1. 세션 검증                                                            │
│     ├─ 세션 존재 및 상태 확인 (UPLOADING)                               │
│     └─ 모든 파트 완료 확인                                               │
│                                                                         │
│  2. SeaweedFS 멀티파트 완료                                              │
│     ├─ parts 목록으로 파일 결합                                         │
│     └─ 최종 objectKey 생성                                              │
│                                                                         │
│  3. ★단일 DB 트랜잭션★ (핵심!)                                          │
│     ├─ INSERT files (id=fileId, state=ACTIVE)                           │
│     ├─ INSERT file_storage_objects (CACHE, AVAILABLE)                   │
│     ├─ INSERT file_storage_objects (NAS, SYNCING)                       │
│     ├─ UPDATE upload_sessions SET status='COMPLETED'                    │
│     ├─ INSERT file_events (UPLOAD)                                      │
│     └─ COMMIT                                                           │
│                                                                         │
│  4. Bull 큐 등록                                                         │
│     └─ NAS_SYNC_UPLOAD 작업 등록                                        │
│                                                                         │
│  5. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 세션 및 파트 검증
SELECT s.*, COUNT(p.id) as partCount
FROM upload_sessions s
LEFT JOIN upload_parts p ON s.id = p.sessionId AND p.status = 'COMPLETED'
WHERE s.id = :sessionId AND s.status = 'UPLOADING'
GROUP BY s.id;

-- 파일 생성 (완료 시점에만!)
INSERT INTO files (id, folderId, name, sizeBytes, mimeType, state, createdAt, updatedAt)
VALUES (:fileId, :folderId, :fileName, :totalSize, :mimeType, 'ACTIVE', NOW(), NOW());

-- 세션 완료
UPDATE upload_sessions SET status = 'COMPLETED', completedAt = NOW()
WHERE id = :sessionId;
```

---

## 1-5. GET /files/multipart/{sessionId}/status - 세션 상태 조회 (Resume용)

### Response

```typescript
interface MultipartStatusResponse {
  sessionId: string;
  status: 'INIT' | 'UPLOADING' | 'COMPLETED' | 'ABORTED' | 'EXPIRED';
  fileName: string;
  totalSize: number;
  uploadedParts: {
    partNumber: number;
    etag: string;
    bytes: number;
  }[];
  nextPartNumber: number;
  totalParts: number;
  uploadedBytes: number;
  remainingBytes: number;
  expiresAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [GET /files/multipart/{sessionId}/status 처리 플로우]                    │
│                                                                         │
│  1. 세션 조회                                                            │
│     ├─ 없음 → 404 반환                                                  │
│     ├─ COMPLETED → 완료 정보 + fileId 반환                              │
│     ├─ ABORTED/EXPIRED → 새 업로드 필요 안내                            │
│     └─ INIT/UPLOADING → 재개 정보 반환                                  │
│                                                                         │
│  2. 완료된 파트 목록 조회                                                │
│     └─ upload_parts에서 status=COMPLETED 조회                           │
│                                                                         │
│  3. 재개 정보 계산                                                       │
│     ├─ nextPartNumber = MAX(partNumber) + 1                             │
│     ├─ uploadedBytes = SUM(bytes)                                       │
│     └─ remainingBytes = totalSize - uploadedBytes                       │
│                                                                         │
│  4. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 1-6. DELETE /files/multipart/{sessionId} - 업로드 취소

### Response

```typescript
interface AbortMultipartResponse {
  sessionId: string;
  status: 'ABORTED';
  message: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [DELETE /files/multipart/{sessionId} 처리 플로우]                        │
│                                                                         │
│  1. 세션 조회                                                            │
│     ├─ 없음 → 404 반환                                                  │
│     ├─ COMPLETED → 409 Conflict (파일 삭제 API 안내)                    │
│     └─ ABORTED/EXPIRED → 200 OK (이미 정리됨)                           │
│                                                                         │
│  2. SeaweedFS 멀티파트 취소                                              │
│     └─ 업로드된 파트 데이터 삭제                                         │
│                                                                         │
│  3. DB 트랜잭션                                                          │
│     ├─ UPDATE upload_sessions SET status='ABORTED'                      │
│     ├─ DELETE upload_parts WHERE sessionId = ?                          │
│     └─ COMMIT                                                           │
│                                                                         │
│  4. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

# 2. 파일 조회/다운로드

## 2-1. GET /files/{fileId} - 파일 정보 조회

### Response

```typescript
interface FileInfoResponse {
  id: string;
  name: string;
  folderId: string;
  path: string;
  size: number;
  mimeType: string;
  state: 'ACTIVE' | 'TRASHED';
  storageStatus: {
    cache: 'AVAILABLE' | 'MISSING' | null;
    nas: 'AVAILABLE' | 'SYNCING' | 'ERROR' | null;
  };
  createdAt: string;
  updatedAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [GET /files/{fileId} 처리 플로우]                                        │
│                                                                         │
│  1. 파일 조회                                                            │
│     └─ files + file_storage_objects JOIN                                │
│                                                                         │
│  2. 상태 계산                                                            │
│     ├─ 캐시 상태: CACHE_SEAWEED 레코드의 availabilityStatus             │
│     └─ NAS 상태: NAS 레코드의 availabilityStatus                        │
│                                                                         │
│  3. 응답 반환                                                            │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
SELECT 
  f.*,
  fso_cache.availabilityStatus as cacheStatus,
  fso_nas.availabilityStatus as nasStatus
FROM files f
LEFT JOIN file_storage_objects fso_cache 
  ON f.id = fso_cache.fileId AND fso_cache.storageType = 'CACHE_SEAWEED'
LEFT JOIN file_storage_objects fso_nas 
  ON f.id = fso_nas.fileId AND fso_nas.storageType = 'NAS'
WHERE f.id = :fileId;
```

---

## 2-2. GET /files/{fileId}/download - 파일 다운로드

### Response

- Content-Type: 파일의 MIME 타입
- Content-Disposition: attachment; filename="파일명"
- Content-Length: 파일 크기
- Body: 파일 스트림

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [GET /files/{fileId}/download 처리 플로우]                               │
│                                                                         │
│  1. 파일 상태 점검                                                       │
│     ├─ state = TRASHED → 400 "휴지통에 있는 파일입니다"                 │
│     └─ state = DELETED → 404 "삭제된 파일입니다"                        │
│                                                                         │
│  2. 캐싱 여부 판단                                                       │
│     └─ file_storage_objects에서 CACHE_SEAWEED 레코드 조회               │
│                                                                         │
│  3-A. 캐시 히트 (CACHE + AVAILABLE)                                     │
│     ├─ ★lease 획득 (atomic)★                                           │
│     │   UPDATE SET leaseCount = leaseCount + 1                         │
│     ├─ SeaweedFS에서 파일 스트림 획득                                   │
│     ├─ ★접근 통계 업데이트★                                             │
│     │   UPDATE SET lastAccessed=NOW(), accessCount=accessCount+1       │
│     └─ ★lease 해제 (finally)★                                          │
│         UPDATE SET leaseCount = GREATEST(leaseCount-1, 0)              │
│                                                                         │
│  3-B. 캐시 미스 (레코드 없음 또는 MISSING/EVICTING)                      │
│     ├─ NAS에서 파일 조회                                                 │
│     ├─ SeaweedFS에 캐시 복원 (백그라운드)                               │
│     ├─ file_storage_objects 생성/업데이트 (lease=1)                     │
│     ├─ NAS에서 파일 스트림 반환                                         │
│     └─ ★lease 해제 (finally)★                                          │
│                                                                         │
│  3-C. 캐시 없음 + NAS 없음                                               │
│     └─ 관리자 알림 + 500 에러                                           │
│                                                                         │
│  4. 파일 스트림 응답                                                     │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 파일 및 저장소 상태 조회
SELECT 
  f.*,
  fso.storageType,
  fso.objectKey,
  fso.availabilityStatus,
  fso.leaseCount
FROM files f
LEFT JOIN file_storage_objects fso ON f.id = fso.fileId
WHERE f.id = :fileId;

-- lease 획득 (캐시 히트 시)
UPDATE file_storage_objects 
SET leaseCount = leaseCount + 1
WHERE fileId = :fileId AND storageType = 'CACHE_SEAWEED';

-- 접근 통계 업데이트
UPDATE file_storage_objects 
SET lastAccessed = NOW(), accessCount = accessCount + 1
WHERE fileId = :fileId AND storageType = 'CACHE_SEAWEED';

-- lease 해제 (finally)
UPDATE file_storage_objects 
SET leaseCount = GREATEST(leaseCount - 1, 0)
WHERE fileId = :fileId AND storageType = 'CACHE_SEAWEED';
```



---

# 3. 파일 수정

## 3-1. PUT /files/{fileId}/rename - 파일명 변경

### Request

```typescript
interface RenameFileRequest {
  newName: string;
  conflictStrategy?: 'ERROR' | 'RENAME';  // 기본값: ERROR
}
```

### Response

```typescript
interface RenameFileResponse {
  id: string;
  name: string;                     // 최종 파일명 (RENAME 시 자동 변경될 수 있음)
  path: string;
  storageStatus: {
    nas: 'SYNCING';
  };
  updatedAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [PUT /files/{fileId}/rename 처리 플로우]                                 │
│                                                                         │
│  1. === BEGIN TRANSACTION ===                                           │
│                                                                         │
│  2. ★파일 락 획득★ (Race Condition 방지)                                │
│     SELECT * FROM files WHERE id = :fileId FOR UPDATE;                  │
│     └─ 없으면 404 반환                                                  │
│                                                                         │
│  3. NAS 동기화 상태 체크                                                 │
│     SELECT * FROM file_storage_objects                                  │
│     WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;          │
│     └─ SYNCING이면 409 Conflict (FILE_SYNCING)                          │
│                                                                         │
│  4. 동일 파일명 존재 확인                                                │
│     SELECT * FROM files                                                 │
│     WHERE folderId = :folderId AND name = :newName                      │
│       AND mimeType = :mimeType AND id != :fileId AND state = 'ACTIVE';  │
│     ├─ 충돌 + ERROR → 409 Conflict (DUPLICATE_FILE_EXISTS)              │
│     └─ 충돌 + RENAME → 자동 이름 변경                                   │
│                                                                         │
│  5. 파일명 업데이트                                                      │
│     UPDATE files SET name = :finalName WHERE id = :fileId;              │
│                                                                         │
│  6. NAS 경로 + 동기화 상태 업데이트                                      │
│     UPDATE file_storage_objects                                         │
│     SET objectKey = :newNasPath, availabilityStatus = 'SYNCING'         │
│     WHERE fileId = :fileId AND storageType = 'NAS';                     │
│                                                                         │
│  7. 이벤트 기록                                                          │
│     INSERT file_events (RENAME, { oldName, newName })                   │
│                                                                         │
│  8. === COMMIT ===                                                      │
│                                                                         │
│  9. Bull 큐 등록                                                         │
│     NAS_SYNC_RENAME 작업 (3회 재시도)                                   │
│                                                                         │
│  10. 응답 반환                                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 파일 락 획득
SELECT * FROM files WHERE id = :fileId FOR UPDATE;

-- NAS 상태 체크
SELECT * FROM file_storage_objects 
WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;

-- 동일 파일명 체크
SELECT * FROM files 
WHERE folderId = :folderId 
  AND name = :newName 
  AND mimeType = :mimeType 
  AND id != :fileId 
  AND state = 'ACTIVE';

-- 파일명 업데이트
UPDATE files SET name = :finalName, updatedAt = NOW() WHERE id = :fileId;

-- NAS 경로 + 상태 업데이트
UPDATE file_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING', updatedAt = NOW()
WHERE fileId = :fileId AND storageType = 'NAS';

-- 이벤트 기록
INSERT INTO file_events (id, fileId, eventType, traceId, payloadJson, occurredAt)
VALUES (:id, :fileId, 'RENAME', :traceId, 
  '{"oldName": "...", "newName": "..."}', NOW());
```

### 에러 처리

| 상황 | HTTP Status | 에러 코드 |
|------|-------------|----------|
| 파일 없음 | 404 | FILE_NOT_FOUND |
| NAS 동기화 중 | 409 | FILE_SYNCING |
| 동일 파일명 존재 | 409 | DUPLICATE_FILE_EXISTS |

---

## 3-2. POST /files/{fileId}/move - 파일 이동

### Request

```typescript
interface MoveFileRequest {
  targetFolderId: string;
  conflictStrategy?: 'ERROR' | 'OVERWRITE' | 'RENAME' | 'SKIP';
}
```

### Response

```typescript
interface MoveFileResponse {
  id: string;
  name: string;
  folderId: string;                 // 새 폴더 ID
  path: string;                     // 새 경로
  skipped?: boolean;                // SKIP인 경우
  reason?: string;
  storageStatus: {
    nas: 'SYNCING';
  };
  updatedAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [POST /files/{fileId}/move 처리 플로우]                                  │
│                                                                         │
│  1. === BEGIN TRANSACTION ===                                           │
│                                                                         │
│  2. 대상 폴더 존재 확인                                                  │
│     SELECT * FROM folders WHERE id = :targetFolderId AND state='ACTIVE';│
│     └─ 없으면 404 (TARGET_FOLDER_NOT_FOUND)                             │
│                                                                         │
│  3. ★파일 락 획득★                                                      │
│     SELECT * FROM files WHERE id = :fileId FOR UPDATE;                  │
│     └─ 없으면 404 반환                                                  │
│                                                                         │
│  4. NAS 동기화 상태 체크                                                 │
│     └─ SYNCING이면 409 Conflict (FILE_SYNCING)                          │
│                                                                         │
│  5. 동일 파일 존재 확인 (대상 폴더에서)                                  │
│     SELECT * FROM files                                                 │
│     WHERE folderId = :targetFolderId AND name = :fileName               │
│       AND mimeType = :mimeType AND state = 'ACTIVE';                    │
│                                                                         │
│  6. 충돌 처리 (conflictStrategy에 따라)                                  │
│     ├─ ERROR → 409 Conflict (DUPLICATE_FILE_EXISTS)                     │
│     ├─ OVERWRITE → 기존 파일 휴지통 이동 (동일 트랜잭션)                │
│     ├─ RENAME → 자동 이름 변경                                          │
│     └─ SKIP → ROLLBACK + 200 OK (skipped: true)                        │
│                                                                         │
│  7. 파일 이동 (폴더 변경)                                                │
│     UPDATE files SET folderId = :targetFolderId, name = :finalName;     │
│                                                                         │
│  8. NAS 경로 + 동기화 상태 업데이트                                      │
│     UPDATE file_storage_objects SET objectKey, availabilityStatus;      │
│                                                                         │
│  9. 이벤트 기록                                                          │
│     INSERT file_events (MOVE, { sourceFolder, targetFolder })           │
│                                                                         │
│  10. === COMMIT ===                                                     │
│                                                                         │
│  11. Bull 큐 등록                                                        │
│      NAS_SYNC_MOVE 작업 (+ OVERWRITE 시 기존 파일 휴지통 이동도)        │
│                                                                         │
│  12. 응답 반환                                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 대상 폴더 확인
SELECT * FROM folders WHERE id = :targetFolderId AND state = 'ACTIVE';

-- 파일 락 획득
SELECT * FROM files WHERE id = :fileId FOR UPDATE;

-- 동일 파일 확인
SELECT * FROM files 
WHERE folderId = :targetFolderId 
  AND name = :fileName 
  AND mimeType = :mimeType 
  AND state = 'ACTIVE';

-- 파일 이동
UPDATE files 
SET folderId = :targetFolderId, name = :finalName, updatedAt = NOW()
WHERE id = :fileId;

-- NAS 경로 업데이트
UPDATE file_storage_objects 
SET objectKey = :newNasPath, availabilityStatus = 'SYNCING', updatedAt = NOW()
WHERE fileId = :fileId AND storageType = 'NAS';
```

### 에러 처리

| 상황 | HTTP Status | 에러 코드 |
|------|-------------|----------|
| 파일 없음 | 404 | FILE_NOT_FOUND |
| 대상 폴더 없음 | 404 | TARGET_FOLDER_NOT_FOUND |
| NAS 동기화 중 | 409 | FILE_SYNCING |
| 동일 파일 존재 | 409 | DUPLICATE_FILE_EXISTS |

---

# 4. 파일 삭제

## 4-1. DELETE /files/{fileId} - 파일 삭제 (휴지통)

### Response

```typescript
interface DeleteFileResponse {
  id: string;
  name: string;
  state: 'TRASHED';
  trashedAt: string;
}
```

### 처리 플로우

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [DELETE /files/{fileId} 처리 플로우]                                     │
│                                                                         │
│  1. === BEGIN TRANSACTION ===                                           │
│                                                                         │
│  2. ★파일 락 획득★                                                      │
│     SELECT * FROM files WHERE id = :fileId FOR UPDATE;                  │
│     └─ 없으면 404 반환                                                  │
│                                                                         │
│  3. NAS 동기화 상태 체크                                                 │
│     SELECT * FROM file_storage_objects                                  │
│     WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;          │
│     └─ SYNCING이면 409 Conflict (FILE_SYNCING)                          │
│                                                                         │
│  4. 파일 상태 변경                                                       │
│     UPDATE files SET state = 'TRASHED' WHERE id = :fileId;              │
│                                                                         │
│  5. trash_metadata 생성                                                 │
│     INSERT trash_metadata (fileId, originalPath, deletedBy, ...)        │
│                                                                         │
│  6. NAS 동기화 상태 업데이트                                             │
│     UPDATE file_storage_objects SET availabilityStatus = 'MOVING'       │
│     WHERE fileId = :fileId AND storageType = 'NAS';                     │
│                                                                         │
│  7. 이벤트 기록                                                          │
│     INSERT file_events (TRASH, { originalPath })                        │
│                                                                         │
│  8. === COMMIT ===                                                      │
│                                                                         │
│  9. Bull 큐 등록                                                         │
│     NAS_MOVE_TO_TRASH 작업 (3회 재시도)                                 │
│                                                                         │
│  10. 응답 반환                                                           │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### SQL

```sql
-- 파일 락 획득
SELECT * FROM files WHERE id = :fileId FOR UPDATE;

-- NAS 상태 체크
SELECT * FROM file_storage_objects 
WHERE fileId = :fileId AND storageType = 'NAS' FOR UPDATE;

-- 파일 상태 변경
UPDATE files SET state = 'TRASHED', updatedAt = NOW() WHERE id = :fileId;

-- 휴지통 메타데이터 생성
INSERT INTO trash_metadata (
  id, fileId, deletedAt, deletedBy, originalPath, originalFolderId, expiresAt
) VALUES (
  :id, :fileId, NOW(), :userId, :originalPath, :folderId, NOW() + INTERVAL '30 days'
);

-- NAS 상태 업데이트
UPDATE file_storage_objects 
SET availabilityStatus = 'MOVING', updatedAt = NOW()
WHERE fileId = :fileId AND storageType = 'NAS';

-- 이벤트 기록
INSERT INTO file_events (id, fileId, eventType, traceId, payloadJson, occurredAt)
VALUES (:id, :fileId, 'TRASH', :traceId, '{"originalPath": "..."}', NOW());
```

### 에러 처리

| 상황 | HTTP Status | 에러 코드 |
|------|-------------|----------|
| 파일 없음 | 404 | FILE_NOT_FOUND |
| NAS 동기화 중 | 409 | FILE_SYNCING |
| 이미 휴지통 | 400 | FILE_ALREADY_TRASHED |

---

## Bull Worker 처리 (공통)

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [Bull Worker - NAS 동기화 처리]                                          │
│                                                                         │
│  설정:                                                                   │
│  - attempts: 3 (최대 3회 재시도)                                        │
│  - backoff: exponential (5초, 10초, 20초)                               │
│                                                                         │
│  성공 시:                                                                │
│  - file_storage_objects.availabilityStatus = 'AVAILABLE'                │
│  - objectKey = 실제 NAS 경로                                            │
│                                                                         │
│  최종 실패 시 (3회 소진):                                                │
│  - file_storage_objects.availabilityStatus = 'ERROR'                    │
│  - 관리자 Alert 발송                                                    │
│  - 큐 일시 정지 (선택적)                                                │
│                                                                         │
│  참고: [050.큐관리.md](./050.큐관리.md)                                  │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 참고 문서

- [001.정의.md](./001.정의.md) - 공통 사항 (로깅, 동시성 제어)
- [0011.엔티티.md](./0011.엔티티.md) - 엔티티 정의
- [050.큐관리.md](./050.큐관리.md) - Bull 큐 관리
- [060.휴지통.md](./060.휴지통.md) - 휴지통 상세 플로우

