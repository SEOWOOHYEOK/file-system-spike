
# 500. 트레이스ID 관리 (nestjs-cls)

---

## 개요

**트레이스ID(Trace ID)**는 하나의 API 요청이 시스템을 통과하는 동안 모든 로그와 이벤트를 연결하는 고유 식별자입니다.

`nestjs-cls`는 **CLS (Continuation Local Storage)** 패턴을 사용하여 요청 전체 생애주기에서 컨텍스트를 안전하게 공유합니다.

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [트레이스ID 흐름]                                                        │
│                                                                         │
│  Client                                                                 │
│    │                                                                    │
│    │  x-trace-id: abc-123 (선택적)                                      │
│    ↓                                                                    │
│  ┌─────────────────────────────────────────────────────────────────┐   │
│  │  NestJS Application                                              │   │
│  │                                                                   │   │
│  │  ClsMiddleware ──────────────────────────────────────────────┐   │   │
│  │    │  • traceId 생성/설정                                     │   │   │
│  │    ↓                                                          │   │   │
│  │  AuthGuard                                                    │   │   │
│  │    │  • userId 설정                                          │   │   │
│  │    ↓                                                     CLS  │   │   │
│  │  Controller                                             Store │   │   │
│  │    │                                                          │   │   │
│  │    ↓                                                          │   │   │
│  │  Service ──→ Repository                                       │   │   │
│  │    │          │                                               │   │   │
│  │    │          ↓                                               │   │   │
│  │    │       file_events.traceId = 'abc-123'                   │   │   │
│  │    ↓                                                          │   │   │
│  │  Response ←───────────────────────────────────────────────────┘   │   │
│  └─────────────────────────────────────────────────────────────────┘   │
│                                                                         │
│  [로그 예시]                                                             │
│  [abc-123] POST /files/123/trash - 시작                                 │
│  [abc-123] DB 트랜잭션 시작                                              │
│  [abc-123] file_events INSERT                                          │
│  [abc-123] NAS 이동 시작                                                │
│  [abc-123] 완료 (250ms)                                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 설치

```bash
npm install nestjs-cls
```

---

## 모듈 구성

### 1. RequestContext 모듈 (전역)

```typescript
// libs/context/request-context.module.ts
import { Global, Module } from '@nestjs/common';
import { ClsModule } from 'nestjs-cls';
import { v4 as uuid } from 'uuid';
import { RequestContextService } from './request-context.service';

@Global()
@Module({
  imports: [
    ClsModule.forRoot({
      global: true,
      middleware: {
        // 모든 라우트에 자동 적용
        mount: true,
        // 트레이스ID 자동 생성
        generateId: true,
        // ID 생성 로직: 헤더 우선, 없으면 UUID 생성
        idGenerator: (req) => {
          return req.headers['x-trace-id']?.toString() ?? uuid();
        },
      },
    }),
  ],
  providers: [RequestContextService],
  exports: [RequestContextService, ClsModule],
})
export class RequestContextModule {}
```

### 2. RequestContext 서비스

```typescript
// libs/context/request-context.service.ts
import { Injectable } from '@nestjs/common';
import { ClsService } from 'nestjs-cls';

/**
 * CLS 저장소 키 상수
 */
export const CLS_KEYS = {
  USER_ID: 'userId',
  USER_ROLE: 'userRole',
  REQUEST_IP: 'requestIp',
  REQUEST_PATH: 'requestPath',
  REQUEST_METHOD: 'requestMethod',
  STARTED_AT: 'startedAt',
} as const;

/**
 * 요청 컨텍스트 서비스
 * 
 * 요청 전체 생애주기에서 공유되는 데이터를 관리합니다.
 * - 트레이스ID (자동 생성)
 * - 사용자 정보 (Guard에서 설정)
 * - 요청 메타데이터
 */
@Injectable()
export class RequestContextService {
  constructor(private readonly cls: ClsService) {}

  // ==================== 트레이스ID ====================

  /**
   * 현재 요청의 트레이스ID
   * ClsMiddleware에서 자동 생성됨
   */
  get traceId(): string {
    return this.cls.getId() ?? 'no-trace';
  }

  // ==================== 사용자 정보 ====================

  /**
   * 현재 요청의 사용자 ID
   */
  get userId(): string | undefined {
    return this.cls.get<string>(CLS_KEYS.USER_ID);
  }

  /**
   * 현재 요청의 사용자 역할
   */
  get userRole(): string | undefined {
    return this.cls.get<string>(CLS_KEYS.USER_ROLE);
  }

  /**
   * 사용자 정보 설정 (Guard에서 호출)
   */
  setUser(userId: string, role?: string): void {
    this.cls.set(CLS_KEYS.USER_ID, userId);
    if (role) {
      this.cls.set(CLS_KEYS.USER_ROLE, role);
    }
  }

  // ==================== 요청 메타데이터 ====================

  /**
   * 요청 IP 주소
   */
  get requestIp(): string | undefined {
    return this.cls.get<string>(CLS_KEYS.REQUEST_IP);
  }

  /**
   * 요청 경로
   */
  get requestPath(): string | undefined {
    return this.cls.get<string>(CLS_KEYS.REQUEST_PATH);
  }

  /**
   * 요청 메서드
   */
  get requestMethod(): string | undefined {
    return this.cls.get<string>(CLS_KEYS.REQUEST_METHOD);
  }

  /**
   * 요청 시작 시간
   */
  get startedAt(): Date | undefined {
    const timestamp = this.cls.get<number>(CLS_KEYS.STARTED_AT);
    return timestamp ? new Date(timestamp) : undefined;
  }

  /**
   * 요청 메타데이터 설정 (Interceptor에서 호출)
   */
  setRequestMetadata(metadata: {
    ip?: string;
    path?: string;
    method?: string;
  }): void {
    if (metadata.ip) this.cls.set(CLS_KEYS.REQUEST_IP, metadata.ip);
    if (metadata.path) this.cls.set(CLS_KEYS.REQUEST_PATH, metadata.path);
    if (metadata.method) this.cls.set(CLS_KEYS.REQUEST_METHOD, metadata.method);
    this.cls.set(CLS_KEYS.STARTED_AT, Date.now());
  }

  // ==================== 유틸리티 ====================

  /**
   * 현재 컨텍스트의 요약 정보 (로깅용)
   */
  getSummary(): Record<string, unknown> {
    return {
      traceId: this.traceId,
      userId: this.userId,
      userRole: this.userRole,
      requestIp: this.requestIp,
      requestPath: this.requestPath,
      requestMethod: this.requestMethod,
    };
  }

  /**
   * 커스텀 데이터 저장
   */
  set<T>(key: string, value: T): void {
    this.cls.set(key, value);
  }

  /**
   * 커스텀 데이터 조회
   */
  get<T>(key: string): T | undefined {
    return this.cls.get<T>(key);
  }
}
```

---

## Guard 통합

### JWT 인증 Guard

```typescript
// guards/jwt-auth.guard.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { RequestContextService } from '@libs/context';

@Injectable()
export class JwtAuthGuard implements CanActivate {
  constructor(
    private readonly jwtService: JwtService,
    private readonly requestContext: RequestContextService,
  ) {}

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest();
    const token = this.extractToken(request);

    if (!token) {
      throw new UnauthorizedException('토큰이 필요합니다');
    }

    try {
      const payload = await this.jwtService.verifyAsync(token);
      
      // ✅ CLS에 사용자 정보 저장
      this.requestContext.setUser(payload.sub, payload.role);
      
      // request 객체에도 저장 (기존 방식 호환)
      request.user = payload;
      
      return true;
    } catch (error) {
      throw new UnauthorizedException('유효하지 않은 토큰입니다');
    }
  }

  private extractToken(request: any): string | null {
    const authHeader = request.headers.authorization;
    if (!authHeader) return null;

    const [type, token] = authHeader.split(' ');
    return type === 'Bearer' ? token : null;
  }
}
```

---

## Interceptor 통합

### 요청 로깅 Interceptor

```typescript
// interceptors/request-logging.interceptor.ts
import {
  Injectable,
  NestInterceptor,
  ExecutionContext,
  CallHandler,
  Logger,
} from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { RequestContextService } from '@libs/context';

@Injectable()
export class RequestLoggingInterceptor implements NestInterceptor {
  private readonly logger = new Logger('HTTP');

  constructor(private readonly requestContext: RequestContextService) {}

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const request = context.switchToHttp().getRequest();
    const { method, url, ip } = request;

    // ✅ CLS에 요청 메타데이터 저장
    this.requestContext.setRequestMetadata({
      ip: ip || request.connection?.remoteAddress,
      path: url,
      method,
    });

    const traceId = this.requestContext.traceId;
    const startTime = Date.now();

    // 요청 시작 로그
    this.logger.log(`[${traceId}] ${method} ${url} - 시작`);

    return next.handle().pipe(
      tap((response) => {
        const duration = Date.now() - startTime;
        this.logger.log(`[${traceId}] ${method} ${url} - 완료 (${duration}ms)`);
      }),
      catchError((error) => {
        const duration = Date.now() - startTime;
        this.logger.error(
          `[${traceId}] ${method} ${url} - 실패 (${duration}ms)`,
          error.stack,
        );
        throw error;
      }),
    );
  }
}
```

---

## Service에서 사용

### 휴지통 서비스 예시

```typescript
// services/trash.service.ts
import { Injectable, Logger } from '@nestjs/common';
import { DataSource } from 'typeorm';
import { RequestContextService } from '@libs/context';
import { NasStorageService } from '@infra/storage/nas';

@Injectable()
export class TrashService {
  private readonly logger = new Logger(TrashService.name);

  constructor(
    private readonly requestContext: RequestContextService,
    private readonly dataSource: DataSource,
    private readonly nasStorage: NasStorageService,
  ) {}

  async moveFileToTrash(fileId: string): Promise<void> {
    const traceId = this.requestContext.traceId;
    const userId = this.requestContext.userId;

    this.logger.log(`[${traceId}] 파일 휴지통 이동 시작: ${fileId}`);

    const file = await this.fileRepository.findOne(fileId);
    const trashPath = `/.trash/${uuid()}${file.path}`;

    // DB 트랜잭션
    await this.dataSource.transaction(async (tx) => {
      // 파일 상태 변경
      await tx.files.update(fileId, { state: 'TRASHED' });

      // trash_metadata 생성
      await tx.trashMetadata.save({
        fileId,
        deletedAt: new Date(),
        deletedBy: userId,  // ✅ CLS에서 가져온 userId
        originalPath: file.path,
        expiresAt: addDays(new Date(), 30),
      });

      // ✅ 이벤트 기록 - traceId로 추적 가능
      await tx.fileEvents.save({
        fileId,
        eventType: 'TRASH',
        traceId,  // ✅ CLS에서 가져온 traceId
        payloadJson: JSON.stringify({
          originalPath: file.path,
          deletedBy: userId,
        }),
      });

      // NAS 상태 변경
      await tx.fileStorageObjects.update(
        { fileId, storageType: 'NAS' },
        { objectKey: trashPath },
      );
    });

    // NAS 파일 이동
    await this.nasStorage.파일을_이동한다(file.path, trashPath);

    this.logger.log(`[${traceId}] 파일 휴지통 이동 완료: ${fileId}`);
  }
}
```

---

## App Module 설정

```typescript
// app.module.ts
import { Module } from '@nestjs/common';
import { APP_INTERCEPTOR, APP_GUARD } from '@nestjs/core';
import { RequestContextModule } from '@libs/context';
import { JwtAuthGuard } from './guards/jwt-auth.guard';
import { RequestLoggingInterceptor } from './interceptors/request-logging.interceptor';

@Module({
  imports: [
    RequestContextModule,  // ✅ 전역 컨텍스트 모듈
    // ... 다른 모듈들
  ],
  providers: [
    // 전역 Interceptor
    {
      provide: APP_INTERCEPTOR,
      useClass: RequestLoggingInterceptor,
    },
    // 전역 Guard (선택)
    // {
    //   provide: APP_GUARD,
    //   useClass: JwtAuthGuard,
    // },
  ],
})
export class AppModule {}
```

---

## 커스텀 Logger 통합

### Trace-aware Logger

```typescript
// libs/logger/trace-logger.service.ts
import { Injectable, Logger, Scope } from '@nestjs/common';
import { RequestContextService } from '@libs/context';

@Injectable()
export class TraceLogger {
  private readonly logger = new Logger();

  constructor(private readonly requestContext: RequestContextService) {}

  private formatMessage(message: string): string {
    const traceId = this.requestContext.traceId;
    return `[${traceId}] ${message}`;
  }

  log(message: string, context?: string): void {
    this.logger.log(this.formatMessage(message), context);
  }

  error(message: string, trace?: string, context?: string): void {
    this.logger.error(this.formatMessage(message), trace, context);
  }

  warn(message: string, context?: string): void {
    this.logger.warn(this.formatMessage(message), context);
  }

  debug(message: string, context?: string): void {
    this.logger.debug(this.formatMessage(message), context);
  }

  verbose(message: string, context?: string): void {
    this.logger.verbose(this.formatMessage(message), context);
  }
}
```

### 사용 예시

```typescript
@Injectable()
export class FileService {
  constructor(
    private readonly logger: TraceLogger,
    private readonly requestContext: RequestContextService,
  ) {}

  async uploadFile(file: Express.Multer.File): Promise<void> {
    this.logger.log(`파일 업로드 시작: ${file.originalname}`);
    
    // ... 업로드 로직
    
    this.logger.log(`파일 업로드 완료: ${file.originalname}`);
  }
}
```

**출력:**
```
[abc-123-def] 파일 업로드 시작: document.pdf
[abc-123-def] 파일 업로드 완료: document.pdf
```

---

## request_transactions 테이블 연동

### 요청 시작 시 트랜잭션 기록

```typescript
// interceptors/transaction-logging.interceptor.ts
import { Injectable, NestInterceptor, ExecutionContext, CallHandler } from '@nestjs/common';
import { Observable } from 'rxjs';
import { tap, catchError } from 'rxjs/operators';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { RequestContextService } from '@libs/context';
import { RequestTransaction } from '@domain/logging/entities';

@Injectable()
export class TransactionLoggingInterceptor implements NestInterceptor {
  constructor(
    private readonly requestContext: RequestContextService,
    @InjectRepository(RequestTransaction)
    private readonly requestTransactionRepo: Repository<RequestTransaction>,
  ) {}

  async intercept(context: ExecutionContext, next: CallHandler): Promise<Observable<any>> {
    const request = context.switchToHttp().getRequest();
    const { method, url, ip, body } = request;

    // 요청 트랜잭션 기록
    const transaction = await this.requestTransactionRepo.save({
      id: this.requestContext.traceId,  // ✅ traceId를 PK로 사용
      requestedAt: new Date(),
      requesterId: this.requestContext.userId,
      requestIp: ip,
      method,
      path: url,
      requestSummary: this.summarizeRequest(method, url, body),
      status: 'PROCESSING',
    });

    return next.handle().pipe(
      tap(async () => {
        // 성공 시 업데이트
        await this.requestTransactionRepo.update(transaction.id, {
          status: 'SUCCESS',
          completedAt: new Date(),
        });
      }),
      catchError(async (error) => {
        // 실패 시 업데이트
        await this.requestTransactionRepo.update(transaction.id, {
          status: 'FAIL',
          completedAt: new Date(),
          errorCode: error.status?.toString() || '500',
          errorMessage: error.message,
        });
        throw error;
      }),
    );
  }

  private summarizeRequest(method: string, url: string, body: any): string {
    return `${method} ${url}`;
  }
}
```

---

## 비동기 작업에서의 컨텍스트 전파

### Bull 큐 작업에 traceId 전달

```typescript
// Bull 큐에 작업 추가 시
await this.nasQueue.add('sync', {
  traceId: this.requestContext.traceId,  // ✅ 명시적으로 전달
  eventType: 'NAS_MOVE_TO_TRASH',
  payload: { ... },
});

// Worker에서 처리 시
@Processor('nas-sync')
export class NasSyncWorker {
  @Process('sync')
  async handleSync(job: Job): Promise<void> {
    const { traceId, eventType, payload } = job.data;
    
    // Worker에서는 CLS가 없으므로 traceId를 직접 사용
    this.logger.log(`[${traceId}] NAS 작업 시작: ${eventType}`);
    
    // ... 작업 처리
  }
}
```

---

## 요청 생애주기 정리

```
┌─────────────────────────────────────────────────────────────────────────┐
│  [NestJS 요청 생애주기 + CLS]                                             │
│                                                                         │
│  1. Middleware (ClsMiddleware)                                          │
│     └─ traceId 생성/설정                                                 │
│                                                                         │
│  2. Guard (JwtAuthGuard)                                                │
│     └─ 인증 처리                                                         │
│     └─ cls.set('userId', ...) ← 사용자 정보 저장                         │
│                                                                         │
│  3. Interceptor (RequestLoggingInterceptor) - Before                    │
│     └─ 요청 로깅 시작                                                    │
│     └─ request_transactions INSERT                                      │
│                                                                         │
│  4. Pipe (ValidationPipe)                                               │
│     └─ DTO 유효성 검사                                                   │
│                                                                         │
│  5. Controller                                                          │
│     └─ this.requestContext.traceId 접근 가능                            │
│                                                                         │
│  6. Service                                                             │
│     └─ this.requestContext.traceId 접근 가능                            │
│     └─ this.requestContext.userId 접근 가능                             │
│     └─ file_events.traceId = this.requestContext.traceId               │
│                                                                         │
│  7. Repository                                                          │
│     └─ DB 작업 수행                                                      │
│                                                                         │
│  8. Interceptor (RequestLoggingInterceptor) - After                     │
│     └─ 응답 로깅                                                         │
│     └─ request_transactions UPDATE                                      │
│                                                                         │
│  9. Response                                                            │
│     └─ x-trace-id 헤더 포함 (선택)                                       │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 참고 문서

- [nestjs-cls 공식 문서](https://papooch.github.io/nestjs-cls/)
- [0011.엔티티.md](./0011.엔티티.md) - request_transactions, file_events 엔티티
- [001.정의.md](./001.정의.md) - 전체 시스템 아키텍처

