# 008-1. 폴더 처리 FLOW

폴더 관련 API의 시퀀스 다이어그램

---

## 1. 폴더 생성

### 1-1. POST /folders - 폴더 생성

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer
    participant Bull as Bull Queue
    participant Worker as Bull Worker
    participant NAS as NAS

    User->>API: POST /folders (name, parentId, conflictStrategy)
    
    API->>API: 1. validate folder name
    
    alt invalid folder name
        API-->>User: 400 INVALID_FOLDER_NAME
    end
    
    API->>API: 2. generate UUID (folderId)
    
    API->>DB: 3. BEGIN TRANSACTION
    
    opt parentId provided
        API->>DB: 4. SELECT * FROM folders WHERE id=parentId FOR UPDATE
        DB-->>API: parent folder info
        
        alt parent not found
            API->>DB: ROLLBACK
            API-->>User: 404 PARENT_FOLDER_NOT_FOUND
        end
    end
    
    API->>DB: 5. check duplicate folder name
    DB-->>API: duplicate status
    
    alt duplicate + ERROR
        API->>DB: ROLLBACK
        API-->>User: 409 DUPLICATE_FOLDER_EXISTS
    end
    
    API->>DB: 6. INSERT folders (state=ACTIVE)
    API->>DB: 7. INSERT sync_events (MKDIR, PENDING) RETURNING id
    API->>DB: 8. INSERT folder_storage_objects (NAS, BUSY, active_sync_event_id)
    API->>Bull: 9. add job (syncEventId)
    API->>DB: COMMIT
    
    
    
    API-->>User: 200 OK (id, name, parentId, path, syncEventId)
    
    Note over Bull,NAS: [Async] Bull Worker
    Bull->>Worker: job (syncEventId)
    Worker->>DB: get sync_event details
    Worker->>DB: UPDATE sync_events (status=PROCESSING)
    Worker->>NAS: mkdir (create folder)
    
    alt NAS success
        NAS-->>Worker: OK
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE folder_storage_objects (AVAILABLE, active_sync_event_id=NULL)
        Worker->>DB: UPDATE sync_events (DONE, processed_at)
        Worker->>DB: COMMIT
    else NAS fail (retryable)
        NAS-->>Worker: Error
        Worker->>DB: UPDATE sync_events (retry_count++, error_message)
        Worker-->>Bull: retry with backoff
    else NAS fail (max retries)
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE sync_events (FAILED)
        Worker->>DB: UPDATE folder_storage_objects (storageType:NAS, availabilityStatus: ERROR, active_sync_event_id=syncEventId)
        Worker->>DB: COMMIT
        Worker->>Alert: send admin alert (syncEventId, RENAME_FAILED)
    end
```

---

## 2. 폴더 조회

### 2-1. GET /folders/{folderId} - 폴더 정보 조회

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer

    User->>API: GET /folders/{folderId}
    
    API->>DB: 1. query folder + storage status (JOIN)
    DB-->>API: folder info + storageStatus
    
    alt folder not found
        API-->>User: 404 FOLDER_NOT_FOUND
    else folder exists
        API->>DB: 2. calculate statistics
        Note over API,DB: fileCount, folderCount, totalSize
        DB-->>API: statistics
        
        API-->>User: 200 OK (id, name, path, state, storageStatus, statistics)
    end
```

---

### 2-2. GET /folders/{folderId}/contents - 폴더 내용 조회

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer

    User->>API: GET /folders/{folderId}/contents (sortBy, sortOrder, page, limit)
    
    API->>DB: 1. check folder exists
    DB-->>API: folder info
    
    alt folder not found or TRASHED
        API-->>User: 404 FOLDER_NOT_FOUND
    end
    
    API->>DB: 2. get breadcrumbs (recursive CTE)
    Note over API,DB: WITH RECURSIVE folder_path AS (...)
    DB-->>API: breadcrumbs list
    
    API->>DB: 3. get subfolders with storage status
    Note over API,DB: JOIN folder_storage_objects
    DB-->>API: folders list
    
    API->>DB: 4. get files with storage status
    Note over API,DB: JOIN file_storage_objects (CACHE + NAS)
    DB-->>API: files list
    
    API->>DB: 5. get total counts
    DB-->>API: totalFolders, totalFiles
    
    API-->>User: 200 OK (breadcrumbs, folders, files, pagination)
```

---

## 3. 폴더 수정

### 3-1. PUT /folders/{folderId}/rename - 폴더명 변경

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer
    participant Bull as Bull Queue
    participant Worker as Bull Worker
    participant NAS as NAS

    User->>API: PUT /folders/{folderId}/rename (newName, conflictStrategy)
    
    API->>DB: 1. BEGIN TRANSACTION
    
    API->>DB: 2. SELECT folder FOR UPDATE (acquire lock)
    DB-->>API: folder info
    
    alt folder not found
        API->>DB: ROLLBACK
        API-->>User: 404 FOLDER_NOT_FOUND
    end
    
    API->>DB: 3. SELECT folder_storage_objects FOR UPDATE
    DB-->>API: storage info (availabilityStatus, active_sync_event_id)
    
    alt BUSY (active_sync_event_id NOT NULL)
        API->>DB: ROLLBACK
        API-->>User: 409 FOLDER_BUSY
    end
    
    API->>DB: 4. check duplicate folder name in same parent
    DB-->>API: duplicate status
    
    alt duplicate + ERROR
        API->>DB: ROLLBACK
        API-->>User: 409 DUPLICATE_FOLDER_EXISTS
    end
    
    API->>DB: 5. UPDATE folders (name, path)
    API->>DB: 6. UPDATE subfolders path (REPLACE)
    Note over DB: WHERE path LIKE oldPath || '/%'
    API->>DB: 7. INSERT sync_events (RENAME_DIR, PENDING, sourcePath, targetPath, metadata:{oldName, newName, oldPath}) RETURNING id
    API->>DB: 8. UPDATE folder_storage_objects (BUSY, new objectKey, active_sync_event_id)
    API->>Bull: 9. add job (syncEventId)
    API->>DB: COMMIT
    

    
    API-->>User: 200 OK (id, name, path, syncEventId)
    
    Note over Bull,NAS: [Async] Bull Worker
    Bull->>Worker: job (syncEventId)
    Worker->>DB: get sync_event details (sourcePath, targetPath, metadata)
    Note over Worker: metadata: {oldName, newName, oldPath}
    Worker->>DB: UPDATE sync_events (status=PROCESSING)
    Worker->>NAS: rename directory (sourcePath → targetPath)
    
    alt NAS success
        NAS-->>Worker: OK
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE folder_storage_objects (AVAILABLE, active_sync_event_id=NULL)
        Worker->>DB: UPDATE sync_events (DONE, processed_at)
        Worker->>DB: COMMIT
    else NAS fail (retryable)
        NAS-->>Worker: Error
        Worker->>DB: UPDATE sync_events (retry_count++, error_message)
        Worker-->>Bull: retry with backoff
    else NAS fail (max retries)
        NAS-->>Worker: Error
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE sync_events SET status='FAILED', error_message
        Worker->>DB: UPDATE folder_storage_objects (storageType:NAS, availabilityStatus: ERROR, active_sync_event_id=syncEventId)
        Worker->>DB: COMMIT
        Worker->>Alert: send admin alert (syncEventId, RENAME_FAILED)
    end
```

> **원복 처리:** NAS 이름 변경 최종 실패 시, DB에 저장된 새 이름/경로를 원래 이름/경로로 복구하여 DB-NAS 정합성 유지

---

### 3-2. POST /folders/{folderId}/move - 폴더 이동

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer
    participant Bull as Bull Queue
    participant Worker as Bull Worker
    participant NAS as NAS

    User->>API: POST /folders/{folderId}/move (targetParentId)
    
    API->>DB: 1. BEGIN TRANSACTION
    
    API->>DB: 2. SELECT * FROM folders WHERE id=targetParentId FOR UPDATE
    DB-->>API: target folder info
    
    alt target not found
        API->>DB: ROLLBACK
        API-->>User: 404 TARGET_FOLDER_NOT_FOUND
    end
    
    API->>DB: 3. SELECT folder FOR UPDATE (acquire lock)
    DB-->>API: folder info
    
    alt folder not found
        API->>DB: ROLLBACK
        API-->>User: 404 FOLDER_NOT_FOUND
    end
    
    API->>DB: 4. check circular move
    Note over API,DB: targetParentId가 folderId의 하위인지 확인
    DB-->>API: circular check result
    
    alt circular move detected
        API->>DB: ROLLBACK
        API-->>User: 409 CIRCULAR_MOVE
    end
    
    API->>DB: 5. SELECT folder_storage_objects FOR UPDATE
    DB-->>API: storage info (availabilityStatus, active_sync_event_id)
    
    alt BUSY (active_sync_event_id NOT NULL)
        API->>DB: ROLLBACK
        API-->>User: 409 FOLDER_BUSY
    end
    
    API->>DB: 6. check duplicate folder name in target
    DB-->>API: duplicate status
    
    alt duplicate folder exists
        API->>DB: ROLLBACK
        API-->>User: 409 DUPLICATE_FOLDER_EXISTS
        Note over User: "이동하려는 경로에 동일한 이름의 폴더가 이미 존재합니다."
    end
    
    API->>DB: 7. UPDATE folders (parentId, name, path)
    API->>DB: 8. UPDATE subfolders path (REPLACE)
    Note over DB: WHERE path LIKE oldPath || '/%'
    API->>DB: 9. INSERT sync_events (MOVE_DIR, PENDING, sourcePath, targetPath, metadata:{originalParentId, targetParentId, originalPath}) RETURNING id
    API->>DB: 10. UPDATE folder_storage_objects (BUSY, new objectKey, active_sync_event_id)
    API->>Bull: 11. add job (syncEventId)
    API->>DB: COMMIT
    
    
    API-->>User: 200 OK (id, name, parentId, path, syncEventId)
    
    Note over Bull,NAS: [Async] Bull Worker
    Bull->>Worker: job (syncEventId)
    Worker->>DB: get sync_event details (sourcePath, targetPath, metadata)
    Note over Worker: metadata: {originalParentId, targetParentId, originalPath}
    Worker->>DB: UPDATE sync_events (status=PROCESSING)
    
    Note over Worker,DB: 2차 방어: 대상 폴더 존재 여부 확인
    Worker->>DB: SELECT * FROM folders WHERE id=metadata.targetParentId AND state='ACTIVE'
    
    alt 폴더 삭제됨 (TARGET_FOLDER_DELETED)
        DB-->>Worker: not found or TRASHED
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE sync_events SET status='FAILED', error_message='TARGET_FOLDER_DELETED'
        Worker->>DB: UPDATE folders SET parent_id = metadata.originalParentId, path = metadata.originalPath
        Worker->>DB: UPDATE folder_storage_objects (AVAILABLE, active_sync_event_id=NULL)
        Worker->>DB: COMMIT
        Worker->>Alert: send alert (folderId, TARGET_FOLDER_DELETED)
    else 폴더 존재
        DB-->>Worker: folder exists
        Worker->>NAS: move directory (mv sourcePath targetPath)
        
        alt NAS success
            NAS-->>Worker: OK
            Worker->>DB: BEGIN
            Worker->>DB: UPDATE folder_storage_objects (AVAILABLE, active_sync_event_id=NULL)
            Worker->>DB: UPDATE sync_events (DONE, processed_at)
            Worker->>DB: COMMIT
        else NAS fail (retryable)
            NAS-->>Worker: Error
            Worker->>DB: UPDATE sync_events (retry_count++, error_message)
            Worker-->>Bull: retry with backoff
        else NAS fail (max retries)
            Worker->>DB: BEGIN
            Worker->>DB: UPDATE sync_events (FAILED)
            Worker->>DB: UPDATE folder_storage_objects (storageType:NAS, availabilityStatus: ERROR, active_sync_event_id=syncEventId)
            Worker->>DB: COMMIT
            Worker->>Alert: send admin alert (syncEventId, RENAME_FAILED)
        end
    end
```

---

## 4. 폴더 삭제

> **정책:** 폴더 안에 파일 또는 하위 폴더가 있으면 삭제 불가 (빈 폴더만 삭제 가능)

### 4-1. DELETE /folders/{folderId} - 폴더 삭제 (휴지통)

```mermaid
sequenceDiagram
    participant User as User
    participant API as API Server
    participant DB as FileMetaDataServer
    participant Bull as Bull Queue
    participant Worker as Bull Worker
    participant NAS as NAS

    User->>API: DELETE /folders/{folderId}
    
    API->>DB: 1. BEGIN TRANSACTION
    
    API->>DB: 2. SELECT folder FOR UPDATE (acquire lock)
    DB-->>API: folder info
    
    alt folder not found
        API->>DB: ROLLBACK
        API-->>User: 404 FOLDER_NOT_FOUND
    else already TRASHED
        API->>DB: ROLLBACK
        API-->>User: 400 FOLDER_ALREADY_TRASHED
    end
    
    Note over API,DB: 정책 체크: 빈 폴더만 삭제 가능
    API->>DB: 3. check child contents (folders + files)
    Note over DB: SELECT COUNT(subfolders), COUNT(files) in one query
    DB-->>API: childFolderCount, childFileCount
    
    alt folder not empty (childFolderCount > 0 OR childFileCount > 0)
        API->>DB: ROLLBACK
        API-->>User: 409 FOLDER_NOT_EMPTY (childFolderCount, childFileCount)
        Note over User: "폴더가 비어있지 않아 삭제할 수 없습니다.<br/>(하위 폴더: N개, 파일: M개)"
    end
    
    API->>DB: 4. SELECT folder_storage_objects FOR UPDATE
    DB-->>API: storage info (availabilityStatus, active_sync_event_id)
    
    alt BUSY (active_sync_event_id NOT NULL)
        API->>DB: ROLLBACK
        API-->>User: 409 FOLDER_BUSY
    end
    
    API->>DB: 5. UPDATE folders SET state='TRASHED'
    API->>DB: 6. INSERT trash_metadata (originalPath, expiresAt)
    API->>DB: 7. INSERT sync_events (MOVE_TO_TRASH, PENDING, sourcePath, targetPath, metadata:{originalPath}) RETURNING id
    API->>DB: 8. UPDATE folder_storage_objects (BUSY, active_sync_event_id)
    API->>DB: 9. INSERT folder_events (TRASH)
    API->>Bull: 10. add job (syncEventId)
    API->>DB: COMMIT
    
    API-->>User: 200 OK (id, name, state=TRASHED, syncEventId)
    
    Note over Bull,NAS: [Async] Bull Worker
    Bull->>Worker: job (syncEventId)
    Worker->>DB: get sync_event details (sourcePath, targetPath, metadata, folderId)
    Note over Worker: metadata: {originalPath}
    Worker->>DB: UPDATE sync_events (status=PROCESSING)
    
    Worker->>NAS: move empty folder to .trash/ (sourcePath → targetPath)
    Note over Worker,NAS: 빈 폴더만 이동
    
    alt NAS success
        NAS-->>Worker: OK
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE folder_storage_objects (AVAILABLE, active_sync_event_id=NULL)
        Worker->>DB: UPDATE sync_events (DONE, processed_at)
        Worker->>DB: COMMIT
    else NAS fail (retryable)
        NAS-->>Worker: Error
        Worker->>DB: UPDATE sync_events (retry_count++, error_message)
        Worker-->>Bull: retry with backoff
    else NAS fail (max retries)
        NAS-->>Worker: Error
        Worker->>DB: BEGIN
        Worker->>DB: UPDATE sync_events (FAILED, error_message)
        Note over Worker,DB: 원복 불필요: DB는 TRASHED 유지, NAS 이동만 실패
        Worker->>DB: UPDATE folder_storage_objects (ERROR, active_sync_event_id=syncEventId)
        Worker->>DB: COMMIT
        Worker->>Alert: send admin alert (syncEventId, MOVE_TO_TRASH_FAILED)
    end
```

```
GET /sync-events/{syncEventId}
→ { id, eventType, status, retryCount, errorMessage, createdAt, processedAt }

GET /folders/{folderId}/sync-status
→ folder_storage_objects.availability_status + active sync_event details
```

---

## 5. 폴더 처리 시 주의사항

### 5-1. 하위 경로 일괄 업데이트

```mermaid
flowchart LR
    subgraph Before["이름 변경 전"]
        A1["/project"] --> B1["/project/docs"]
        B1 --> C1["/project/docs/api"]
        A1 --> D1["/project/src"]
    end
    
    subgraph After["project → myproject 변경 후"]
        A2["/myproject"] --> B2["/myproject/docs"]
        B2 --> C2["/myproject/docs/api"]
        A2 --> D2["/myproject/src"]
    end
    
    Before --> |"REPLACE(path, '/project', '/myproject')"| After
```

### 5-2. 순환 이동 방지

```mermaid
flowchart TB
    subgraph Folder_Structure["폴더 구조"]
        ROOT["/root"] --> A["/root/A"]
        A --> B["/root/A/B"]
        B --> C["/root/A/B/C"]
    end
    
    subgraph Invalid_Move["❌ 불가능한 이동"]
        A2["A"] --> |"move to C"| C2["C (A의 하위)"]
    end
    
    Note1["A를 C로 이동하면<br/>A/B/C/A/B/C... 순환 발생"]
```

**순환 체크 쿼리:**
```sql
SELECT * FROM folders 
WHERE id = :targetParentId 
  AND path LIKE (SELECT path FROM folders WHERE id = :folderId) || '/%';
```

### 5-3. 폴더 삭제 정책

> **정책:** 빈 폴더만 삭제 가능 (하위 파일/폴더가 있으면 삭제 불가)

```mermaid
flowchart TB
    subgraph Policy_Check["정책 체크 (API 앞단)"]
        A["DELETE /folders/{folderId}"] --> B["하위 폴더/파일 수 조회"]
        B --> C{"비어있는가?<br/>folderCount=0 AND fileCount=0"}
        C -->|No| D["409 FOLDER_NOT_EMPTY<br/>(folderCount, fileCount 포함)"]
        C -->|Yes| E["삭제 진행"]
    end
    
    subgraph Transaction["트랜잭션"]
        E --> F["폴더 TRASHED"]
        F --> G["trash_metadata 생성"]
        G --> H["sync_events INSERT"]
    end
    
    subgraph NAS["NAS 동기화"]
        I["빈 폴더 .trash/ 이동"]
    end
    
    Transaction --> |"Bull Worker"| NAS
    
    style D fill:#ffcccc
```

**폴더 삭제 실패 시 사용자 안내:**
- 응답: `409 FOLDER_NOT_EMPTY { childFolderCount: N, childFileCount: M }`
- 메시지: "폴더가 비어있지 않아 삭제할 수 없습니다. (하위 폴더: N개, 파일: M개)"

---

## 참고

- [008.폴더.md](./008.폴더.md) - API 상세 정의
- [005-1.파일_처리_FLOW.md](../파일/005-1.파일_처리_FLOW.md) - 파일 처리 FLOW
- [001.정의.md](../001.정의.md) - 공통 사항
- [050.큐관리.md](../050.큐관리.md) - Bull 큐 관리
- [060.휴지통.md](../060.휴지통_version0.0.2.md) - 휴지통 상세 플로우
- [061.휴지통_비동기처리.md](../061.휴지통_비동기처리.md) - 휴지통 비동기 처리
