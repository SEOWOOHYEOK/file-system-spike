# 인증 전략 (Authentication Strategy)

## 개요

SSO(Single Sign-On) 시스템이 추후 도입될 예정이므로, **전략 패턴(Strategy Pattern)**을 적용하여 인증 로직을 쉽게 교체할 수 있도록 설계합니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│  [현재 상태]                       [목표 상태]                        │
│                                                                     │
│  내부 사용자: 자체 인증      →     내부 사용자: SSO 인증              │
│  게스트 유저: 자체 인증      →     게스트 유저: SSO (외부 게스트)      │
│                                                                     │
│  ※ 전략 패턴으로 갈아끼우기 쉽게 설계                                │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 설계 원칙

### 1. 전략 패턴 (Strategy Pattern)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [전략 패턴 구조]                                                     │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │                    AuthContext (컨텍스트)                    │    │
│  │  - 현재 활성화된 인증 전략 보유                               │    │
│  │  - 인증 요청을 전략에 위임                                    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│                              ▼                                      │
│  ┌─────────────────────────────────────────────────────────────┐    │
│  │              IAuthStrategy (인터페이스)                       │    │
│  │  + authenticate(credentials): Promise<AuthResult>            │    │
│  │  + validateToken(token): Promise<TokenPayload>               │    │
│  │  + refreshToken(refreshToken): Promise<TokenPair>            │    │
│  │  + logout(userId): Promise<void>                             │    │
│  │  + getUserInfo(userId): Promise<UserInfo>                    │    │
│  └─────────────────────────────────────────────────────────────┘    │
│                              │                                      │
│              ┌───────────────┼───────────────┐                      │
│              ▼               ▼               ▼                      │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐           │
│  │ LocalAuth     │  │ SSOAuth       │  │ GuestAuth     │           │
│  │ Strategy      │  │ Strategy      │  │ Strategy      │           │
│  │ (현재 사용)   │  │ (추후 도입)   │  │ (게스트 전용) │           │
│  └───────────────┘  └───────────────┘  └───────────────┘           │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 2. 의존성 역전 (Dependency Inversion)

- 비즈니스 로직은 **인터페이스(IAuthStrategy)**에만 의존
- 구체적인 인증 구현체는 **주입(Injection)**으로 제공
- 환경 변수 또는 설정으로 전략 선택

---

## 인터페이스 정의

### IAuthStrategy (인증 전략 인터페이스)

```typescript
// src/domain/auth/interfaces/auth-strategy.interface.ts

export interface IAuthStrategy {
  /**
   * 사용자 인증
   * @param credentials - 인증 정보 (username/password, token 등)
   * @returns 인증 결과 (토큰, 사용자 정보)
   */
  authenticate(credentials: AuthCredentials): Promise<AuthResult>;

  /**
   * 토큰 유효성 검증
   * @param token - Access Token
   * @returns 토큰에서 추출한 사용자 정보
   */
  validateToken(token: string): Promise<TokenPayload>;

  /**
   * 토큰 갱신
   * @param refreshToken - Refresh Token
   * @returns 새로운 토큰 쌍
   */
  refreshToken(refreshToken: string): Promise<TokenPair>;

  /**
   * 로그아웃
   * @param userId - 사용자 ID
   */
  logout(userId: string): Promise<void>;

  /**
   * 사용자 정보 조회
   * @param userId - 사용자 ID
   * @returns 사용자 상세 정보
   */
  getUserInfo(userId: string): Promise<UserInfo>;

  /**
   * 전략 이름 (디버깅/로깅용)
   */
  getStrategyName(): string;
}
```

### IGuestAuthStrategy (게스트 인증 전략 인터페이스)

```typescript
// src/domain/auth/interfaces/guest-auth-strategy.interface.ts

export interface IGuestAuthStrategy extends IAuthStrategy {
  /**
   * 게스트 등록
   * @param guestInfo - 게스트 정보
   * @returns 생성된 게스트 ID
   */
  registerGuest(guestInfo: GuestRegistration): Promise<string>;

  /**
   * 이메일 인증
   * @param token - 인증 토큰
   */
  verifyEmail(token: string): Promise<void>;

  /**
   * 게스트 비밀번호 설정/변경
   * @param guestId - 게스트 ID
   * @param password - 새 비밀번호
   */
  setPassword(guestId: string, password: string): Promise<void>;

  /**
   * 공유 링크 접근 권한 확인
   * @param guestId - 게스트 ID
   * @param shareCode - 공유 코드
   */
  checkShareAccess(guestId: string, shareCode: string): Promise<boolean>;
}
```

### 공통 타입 정의

```typescript
// src/domain/auth/types/auth.types.ts

// 인증 자격 증명
export interface AuthCredentials {
  type: 'LOCAL' | 'SSO' | 'GUEST' | 'SSO_GUEST';
  username?: string;
  password?: string;
  ssoToken?: string;
  email?: string;
  shareCode?: string;  // 게스트의 공유 링크 접근 시
}

// 인증 결과
export interface AuthResult {
  success: boolean;
  userId: string;
  userType: 'INTERNAL' | 'GUEST';
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
  userInfo: UserInfo;
  authMethod: 'LOCAL' | 'SSO';  // 실제 인증 방식 (로깅용)
}

// 토큰 페이로드
export interface TokenPayload {
  userId: string;
  userType: 'INTERNAL' | 'GUEST';
  email: string;
  roles: string[];
  permissions: string[];
  iat: number;
  exp: number;
}

// 토큰 쌍
export interface TokenPair {
  accessToken: string;
  refreshToken: string;
  expiresIn: number;
}

// 사용자 정보
export interface UserInfo {
  id: string;
  email: string;
  name: string;
  userType: 'INTERNAL' | 'GUEST';
  roles: string[];
  permissions: string[];
  company?: string;  // 게스트용
  department?: string;  // 내부 사용자용
  metadata?: Record<string, any>;  // SSO에서 전달받는 추가 정보
}
```

---

## 구현 전략

### Phase 1: 현재 (자체 인증)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Phase 1 - 자체 인증 시스템]                                        │
│                                                                     │
│  내부 사용자:                                                        │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐         │
│  │   로그인    │ →  │ LocalAuthStrategy│ →  │   users     │         │
│  │  (ID/PW)   │    │  (JWT 발급)      │    │  테이블     │         │
│  └─────────────┘    └─────────────────┘    └─────────────┘         │
│                                                                     │
│  게스트 유저:                                                        │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐         │
│  │  게스트     │ →  │ LocalGuestAuth  │ →  │ guest_users │         │
│  │  로그인    │    │   Strategy       │    │  테이블     │         │
│  └─────────────┘    └─────────────────┘    └─────────────┘         │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Phase 2: SSO 도입 (내부 사용자)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Phase 2 - SSO 도입 (내부 사용자)]                                  │
│                                                                     │
│  내부 사용자:                                                        │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐         │
│  │   SSO       │ →  │  SSOAuthStrategy│ →  │   SSO       │         │
│  │  로그인    │    │  (토큰 검증)     │    │  서버       │         │
│  └─────────────┘    └─────────────────┘    └─────────────┘         │
│                              │                                      │
│                              ▼                                      │
│                     ┌─────────────────┐                            │
│                     │  users 테이블   │ ← SSO ID 매핑              │
│                     │ (ssoId 컬럼 추가)│                            │
│                     └─────────────────┘                            │
│                                                                     │
│  게스트 유저: (Phase 1과 동일 - 자체 인증 유지)                      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Phase 3: SSO 확장 (게스트 포함)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [Phase 3 - SSO 게스트 확장]                                         │
│                                                                     │
│  내부 사용자:                                                        │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐         │
│  │   SSO       │ →  │  SSOAuthStrategy│ →  │   SSO       │         │
│  │  로그인    │    │                  │    │  서버       │         │
│  └─────────────┘    └─────────────────┘    └─────────────┘         │
│                                                                     │
│  게스트 유저:                                                        │
│  ┌─────────────┐    ┌─────────────────┐    ┌─────────────┐         │
│  │   SSO       │ →  │ SSOGuestAuth    │ →  │   SSO       │         │
│  │  (외부계정) │    │   Strategy       │    │  (외부게스트)│         │
│  └─────────────┘    └─────────────────┘    └─────────────┘         │
│                              │                                      │
│                              ▼                                      │
│                     ┌─────────────────┐                            │
│                     │ guest_users     │ ← SSO ID 매핑              │
│                     │ (ssoId 컬럼 추가)│                            │
│                     └─────────────────┘                            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 구현 코드 예시

### 1. 인증 모듈 구조

```
src/
├── domain/
│   └── auth/
│       ├── interfaces/
│       │   ├── auth-strategy.interface.ts
│       │   └── guest-auth-strategy.interface.ts
│       └── types/
│           └── auth.types.ts
│
├── infra/
│   └── auth/
│       ├── strategies/
│       │   ├── local-auth.strategy.ts      # 자체 인증 (현재)
│       │   ├── local-guest-auth.strategy.ts # 게스트 자체 인증 (현재)
│       │   ├── sso-auth.strategy.ts        # SSO 인증 (추후)
│       │   └── sso-guest-auth.strategy.ts  # SSO 게스트 (추후)
│       ├── auth.module.ts
│       └── auth.provider.ts                # 전략 주입 설정
│
└── business/
    └── auth/
        └── auth.service.ts                 # 인증 서비스 (전략 사용)
```

### 2. 전략 제공자 (Strategy Provider)

```typescript
// src/infra/auth/auth.provider.ts

import { Provider } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { IAuthStrategy } from '@/domain/auth/interfaces/auth-strategy.interface';
import { IGuestAuthStrategy } from '@/domain/auth/interfaces/guest-auth-strategy.interface';
import { LocalAuthStrategy } from './strategies/local-auth.strategy';
import { LocalGuestAuthStrategy } from './strategies/local-guest-auth.strategy';
import { SSOAuthStrategy } from './strategies/sso-auth.strategy';
import { SSOGuestAuthStrategy } from './strategies/sso-guest-auth.strategy';

// 인증 전략 토큰
export const AUTH_STRATEGY = 'AUTH_STRATEGY';
export const GUEST_AUTH_STRATEGY = 'GUEST_AUTH_STRATEGY';

// 내부 사용자 인증 전략 Provider
export const AuthStrategyProvider: Provider = {
  provide: AUTH_STRATEGY,
  useFactory: (configService: ConfigService): IAuthStrategy => {
    const authMode = configService.get<string>('AUTH_MODE', 'LOCAL');
    
    switch (authMode) {
      case 'SSO':
        console.log('[Auth] SSO 인증 전략 활성화');
        return new SSOAuthStrategy(configService);
      case 'LOCAL':
      default:
        console.log('[Auth] 자체 인증 전략 활성화');
        return new LocalAuthStrategy(configService);
    }
  },
  inject: [ConfigService],
};

// 게스트 인증 전략 Provider
export const GuestAuthStrategyProvider: Provider = {
  provide: GUEST_AUTH_STRATEGY,
  useFactory: (configService: ConfigService): IGuestAuthStrategy => {
    const guestAuthMode = configService.get<string>('GUEST_AUTH_MODE', 'LOCAL');
    
    switch (guestAuthMode) {
      case 'SSO':
        console.log('[Auth] SSO 게스트 인증 전략 활성화');
        return new SSOGuestAuthStrategy(configService);
      case 'LOCAL':
      default:
        console.log('[Auth] 자체 게스트 인증 전략 활성화');
        return new LocalGuestAuthStrategy(configService);
    }
  },
  inject: [ConfigService],
};
```

### 3. 인증 서비스 (전략 사용)

```typescript
// src/business/auth/auth.service.ts

import { Injectable, Inject } from '@nestjs/common';
import { IAuthStrategy } from '@/domain/auth/interfaces/auth-strategy.interface';
import { IGuestAuthStrategy } from '@/domain/auth/interfaces/guest-auth-strategy.interface';
import { AUTH_STRATEGY, GUEST_AUTH_STRATEGY } from '@/infra/auth/auth.provider';
import { AuthCredentials, AuthResult, TokenPayload } from '@/domain/auth/types/auth.types';

@Injectable()
export class AuthService {
  constructor(
    @Inject(AUTH_STRATEGY)
    private readonly authStrategy: IAuthStrategy,
    
    @Inject(GUEST_AUTH_STRATEGY)
    private readonly guestAuthStrategy: IGuestAuthStrategy,
  ) {
    console.log(`[AuthService] 내부 사용자 인증: ${this.authStrategy.getStrategyName()}`);
    console.log(`[AuthService] 게스트 인증: ${this.guestAuthStrategy.getStrategyName()}`);
  }

  /**
   * 내부 사용자 로그인
   */
  async loginInternal(credentials: AuthCredentials): Promise<AuthResult> {
    // 전략에 위임 - 구현체가 무엇이든 동일한 인터페이스
    return this.authStrategy.authenticate(credentials);
  }

  /**
   * 게스트 로그인
   */
  async loginGuest(credentials: AuthCredentials): Promise<AuthResult> {
    return this.guestAuthStrategy.authenticate(credentials);
  }

  /**
   * 토큰 검증 (내부 사용자)
   */
  async validateInternalToken(token: string): Promise<TokenPayload> {
    return this.authStrategy.validateToken(token);
  }

  /**
   * 토큰 검증 (게스트)
   */
  async validateGuestToken(token: string): Promise<TokenPayload> {
    return this.guestAuthStrategy.validateToken(token);
  }

  /**
   * 토큰 갱신
   */
  async refreshTokens(refreshToken: string, userType: 'INTERNAL' | 'GUEST') {
    if (userType === 'INTERNAL') {
      return this.authStrategy.refreshToken(refreshToken);
    }
    return this.guestAuthStrategy.refreshToken(refreshToken);
  }

  /**
   * 게스트 등록
   */
  async registerGuest(guestInfo: GuestRegistration): Promise<string> {
    return this.guestAuthStrategy.registerGuest(guestInfo);
  }

  /**
   * 공유 링크 접근 권한 확인
   */
  async checkGuestShareAccess(guestId: string, shareCode: string): Promise<boolean> {
    return this.guestAuthStrategy.checkShareAccess(guestId, shareCode);
  }
}
```

### 4. 자체 인증 전략 구현 (현재)

```typescript
// src/infra/auth/strategies/local-auth.strategy.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { JwtService } from '@nestjs/jwt';
import * as bcrypt from 'bcrypt';
import { IAuthStrategy } from '@/domain/auth/interfaces/auth-strategy.interface';
import { AuthCredentials, AuthResult, TokenPayload, TokenPair, UserInfo } from '@/domain/auth/types/auth.types';
import { UserRepository } from '@/infra/repositories/user.repository';

@Injectable()
export class LocalAuthStrategy implements IAuthStrategy {
  constructor(
    private readonly configService: ConfigService,
    private readonly jwtService: JwtService,
    private readonly userRepository: UserRepository,
  ) {}

  getStrategyName(): string {
    return 'LOCAL';
  }

  async authenticate(credentials: AuthCredentials): Promise<AuthResult> {
    const { username, password } = credentials;

    // 1. 사용자 조회
    const user = await this.userRepository.findByUsername(username);
    if (!user) {
      throw new UnauthorizedException('사용자를 찾을 수 없습니다.');
    }

    // 2. 비밀번호 검증
    const isPasswordValid = await bcrypt.compare(password, user.passwordHash);
    if (!isPasswordValid) {
      throw new UnauthorizedException('비밀번호가 일치하지 않습니다.');
    }

    // 3. 토큰 생성
    const payload: TokenPayload = {
      userId: user.id,
      userType: 'INTERNAL',
      email: user.email,
      roles: user.roles,
      permissions: user.permissions,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600, // 1시간
    };

    const accessToken = this.jwtService.sign(payload);
    const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' });

    return {
      success: true,
      userId: user.id,
      userType: 'INTERNAL',
      accessToken,
      refreshToken,
      expiresIn: 3600,
      userInfo: {
        id: user.id,
        email: user.email,
        name: user.name,
        userType: 'INTERNAL',
        roles: user.roles,
        permissions: user.permissions,
        department: user.department,
      },
      authMethod: 'LOCAL',
    };
  }

  async validateToken(token: string): Promise<TokenPayload> {
    try {
      return this.jwtService.verify(token);
    } catch (error) {
      throw new UnauthorizedException('유효하지 않은 토큰입니다.');
    }
  }

  async refreshToken(refreshToken: string): Promise<TokenPair> {
    const payload = await this.validateToken(refreshToken);
    
    const newPayload = {
      ...payload,
      iat: Math.floor(Date.now() / 1000),
      exp: Math.floor(Date.now() / 1000) + 3600,
    };

    return {
      accessToken: this.jwtService.sign(newPayload),
      refreshToken: this.jwtService.sign(newPayload, { expiresIn: '7d' }),
      expiresIn: 3600,
    };
  }

  async logout(userId: string): Promise<void> {
    // 로컬 인증에서는 토큰 블랙리스트 처리 (선택적)
    // await this.tokenBlacklistService.add(userId);
  }

  async getUserInfo(userId: string): Promise<UserInfo> {
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new NotFoundException('사용자를 찾을 수 없습니다.');
    }

    return {
      id: user.id,
      email: user.email,
      name: user.name,
      userType: 'INTERNAL',
      roles: user.roles,
      permissions: user.permissions,
      department: user.department,
    };
  }
}
```

### 5. SSO 인증 전략 구현 (추후)

```typescript
// src/infra/auth/strategies/sso-auth.strategy.ts

import { Injectable } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { HttpService } from '@nestjs/axios';
import { IAuthStrategy } from '@/domain/auth/interfaces/auth-strategy.interface';
import { AuthCredentials, AuthResult, TokenPayload, TokenPair, UserInfo } from '@/domain/auth/types/auth.types';
import { UserRepository } from '@/infra/repositories/user.repository';

@Injectable()
export class SSOAuthStrategy implements IAuthStrategy {
  private readonly ssoServerUrl: string;
  private readonly ssoClientId: string;
  private readonly ssoClientSecret: string;

  constructor(
    private readonly configService: ConfigService,
    private readonly httpService: HttpService,
    private readonly userRepository: UserRepository,
  ) {
    this.ssoServerUrl = this.configService.get<string>('SSO_SERVER_URL');
    this.ssoClientId = this.configService.get<string>('SSO_CLIENT_ID');
    this.ssoClientSecret = this.configService.get<string>('SSO_CLIENT_SECRET');
  }

  getStrategyName(): string {
    return 'SSO';
  }

  async authenticate(credentials: AuthCredentials): Promise<AuthResult> {
    const { ssoToken } = credentials;

    // 1. SSO 서버에 토큰 검증 요청
    const ssoResponse = await this.httpService.axiosRef.post(
      `${this.ssoServerUrl}/oauth/token/validate`,
      { token: ssoToken },
      {
        headers: {
          'Authorization': `Basic ${Buffer.from(`${this.ssoClientId}:${this.ssoClientSecret}`).toString('base64')}`,
        },
      }
    );

    const ssoUser = ssoResponse.data;

    // 2. 로컬 사용자 매핑 (SSO ID로 조회 또는 생성)
    let user = await this.userRepository.findBySsoId(ssoUser.sub);
    
    if (!user) {
      // SSO에서 처음 로그인하는 사용자 - 로컬에 매핑 레코드 생성
      user = await this.userRepository.createFromSSO({
        ssoId: ssoUser.sub,
        email: ssoUser.email,
        name: ssoUser.name,
        department: ssoUser.department,
        roles: this.mapSSOGroupsToRoles(ssoUser.groups),
      });
    } else {
      // 기존 사용자 - 정보 동기화
      await this.userRepository.syncFromSSO(user.id, {
        email: ssoUser.email,
        name: ssoUser.name,
        department: ssoUser.department,
        roles: this.mapSSOGroupsToRoles(ssoUser.groups),
      });
    }

    // 3. 로컬 토큰 발급 (SSO 토큰 래핑)
    const payload: TokenPayload = {
      userId: user.id,
      userType: 'INTERNAL',
      email: user.email,
      roles: user.roles,
      permissions: user.permissions,
      iat: Math.floor(Date.now() / 1000),
      exp: ssoUser.exp, // SSO 토큰 만료 시간 사용
    };

    return {
      success: true,
      userId: user.id,
      userType: 'INTERNAL',
      accessToken: ssoToken, // SSO 토큰 그대로 사용
      refreshToken: ssoUser.refresh_token,
      expiresIn: ssoUser.exp - Math.floor(Date.now() / 1000),
      userInfo: {
        id: user.id,
        email: user.email,
        name: user.name,
        userType: 'INTERNAL',
        roles: user.roles,
        permissions: user.permissions,
        department: user.department,
        metadata: ssoUser.metadata,
      },
      authMethod: 'SSO',
    };
  }

  async validateToken(token: string): Promise<TokenPayload> {
    // SSO 서버에 토큰 검증 요청
    try {
      const response = await this.httpService.axiosRef.post(
        `${this.ssoServerUrl}/oauth/token/introspect`,
        { token },
        {
          headers: {
            'Authorization': `Basic ${Buffer.from(`${this.ssoClientId}:${this.ssoClientSecret}`).toString('base64')}`,
          },
        }
      );

      if (!response.data.active) {
        throw new UnauthorizedException('토큰이 만료되었습니다.');
      }

      // SSO 응답을 로컬 TokenPayload로 변환
      const user = await this.userRepository.findBySsoId(response.data.sub);
      
      return {
        userId: user.id,
        userType: 'INTERNAL',
        email: response.data.email,
        roles: user.roles,
        permissions: user.permissions,
        iat: response.data.iat,
        exp: response.data.exp,
      };
    } catch (error) {
      throw new UnauthorizedException('토큰 검증 실패');
    }
  }

  async refreshToken(refreshToken: string): Promise<TokenPair> {
    // SSO 서버에 토큰 갱신 요청
    const response = await this.httpService.axiosRef.post(
      `${this.ssoServerUrl}/oauth/token`,
      {
        grant_type: 'refresh_token',
        refresh_token: refreshToken,
      },
      {
        headers: {
          'Authorization': `Basic ${Buffer.from(`${this.ssoClientId}:${this.ssoClientSecret}`).toString('base64')}`,
        },
      }
    );

    return {
      accessToken: response.data.access_token,
      refreshToken: response.data.refresh_token,
      expiresIn: response.data.expires_in,
    };
  }

  async logout(userId: string): Promise<void> {
    // SSO 서버에 로그아웃 요청
    const user = await this.userRepository.findById(userId);
    
    await this.httpService.axiosRef.post(
      `${this.ssoServerUrl}/oauth/logout`,
      { sub: user.ssoId },
      {
        headers: {
          'Authorization': `Basic ${Buffer.from(`${this.ssoClientId}:${this.ssoClientSecret}`).toString('base64')}`,
        },
      }
    );
  }

  async getUserInfo(userId: string): Promise<UserInfo> {
    const user = await this.userRepository.findById(userId);
    
    // SSO에서 최신 정보 조회 (선택적)
    const ssoUserInfo = await this.httpService.axiosRef.get(
      `${this.ssoServerUrl}/userinfo`,
      {
        headers: { 'Authorization': `Bearer ${user.lastSsoToken}` },
      }
    );

    return {
      id: user.id,
      email: ssoUserInfo.data.email,
      name: ssoUserInfo.data.name,
      userType: 'INTERNAL',
      roles: user.roles,
      permissions: user.permissions,
      department: ssoUserInfo.data.department,
      metadata: ssoUserInfo.data,
    };
  }

  // SSO 그룹을 로컬 역할로 매핑
  private mapSSOGroupsToRoles(groups: string[]): string[] {
    const roleMapping: Record<string, string> = {
      'SSO_ADMIN': 'ADMIN',
      'SSO_USER': 'USER',
      'SSO_GUEST_ADMIN': 'GUEST_ADMIN',
    };

    return groups
      .filter(g => roleMapping[g])
      .map(g => roleMapping[g]);
  }
}
```

---

## 데이터베이스 스키마 변경

### Phase 2를 위한 users 테이블 수정

```sql
-- SSO 연동을 위한 컬럼 추가
ALTER TABLE users ADD COLUMN sso_id VARCHAR(255) UNIQUE;
ALTER TABLE users ADD COLUMN sso_provider VARCHAR(50);  -- 'INTERNAL_SSO', 'OKTA', 'AZURE_AD' 등
ALTER TABLE users ADD COLUMN last_sso_sync_at TIMESTAMP;
ALTER TABLE users ADD COLUMN auth_method VARCHAR(20) DEFAULT 'LOCAL';  -- 'LOCAL' | 'SSO'

CREATE INDEX idx_users_sso_id ON users(sso_id);
```

### Phase 3를 위한 guest_users 테이블 수정

```sql
-- SSO 게스트 연동을 위한 컬럼 추가
ALTER TABLE guest_users ADD COLUMN sso_id VARCHAR(255) UNIQUE;
ALTER TABLE guest_users ADD COLUMN sso_provider VARCHAR(50);
ALTER TABLE guest_users ADD COLUMN last_sso_sync_at TIMESTAMP;
ALTER TABLE guest_users ADD COLUMN auth_method VARCHAR(20) DEFAULT 'LOCAL';  -- 'LOCAL' | 'SSO'

CREATE INDEX idx_guest_users_sso_id ON guest_users(sso_id);
```

---

## 환경 설정

### .env 설정

```bash
# ===== 인증 설정 =====

# 내부 사용자 인증 모드 (LOCAL | SSO)
AUTH_MODE=LOCAL

# 게스트 인증 모드 (LOCAL | SSO)
GUEST_AUTH_MODE=LOCAL

# ===== SSO 설정 (AUTH_MODE=SSO 시 필요) =====

# SSO 서버 URL
SSO_SERVER_URL=https://sso.company.com

# SSO 클라이언트 정보
SSO_CLIENT_ID=file-server-app
SSO_CLIENT_SECRET=your-client-secret

# SSO 콜백 URL
SSO_CALLBACK_URL=https://fileserver.company.com/auth/callback

# SSO 스코프
SSO_SCOPES=openid,profile,email,groups

# SSO 게스트 설정 (GUEST_AUTH_MODE=SSO 시 필요)
SSO_GUEST_REALM=external-guests
```

---

## 전환 체크리스트

### Phase 1 → Phase 2 전환 (내부 사용자 SSO)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [전환 체크리스트]                                                    │
│                                                                     │
│  □ 1. SSO 서버 연동 테스트 완료                                      │
│  □ 2. users 테이블 스키마 마이그레이션                                │
│  □ 3. SSOAuthStrategy 구현 및 테스트                                 │
│  □ 4. 기존 사용자 SSO ID 매핑 (일괄 또는 첫 로그인 시)               │
│  □ 5. .env에 AUTH_MODE=SSO 설정                                     │
│  □ 6. 배포 및 모니터링                                               │
│  □ 7. 롤백 계획 준비 (AUTH_MODE=LOCAL로 복구)                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### Phase 2 → Phase 3 전환 (게스트 SSO)

```
┌─────────────────────────────────────────────────────────────────────┐
│  [전환 체크리스트]                                                    │
│                                                                     │
│  □ 1. SSO 서버에 외부 게스트 Realm 설정                              │
│  □ 2. guest_users 테이블 스키마 마이그레이션                          │
│  □ 3. SSOGuestAuthStrategy 구현 및 테스트                            │
│  □ 4. 기존 게스트 SSO ID 매핑 (이메일 기반 자동 매핑 또는 재등록)    │
│  □ 5. .env에 GUEST_AUTH_MODE=SSO 설정                               │
│  □ 6. 공유 링크 접근 플로우 테스트                                   │
│  □ 7. 배포 및 모니터링                                               │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 롤백 전략

```
┌─────────────────────────────────────────────────────────────────────┐
│  [롤백 전략]                                                          │
│                                                                     │
│  SSO 장애 또는 문제 발생 시:                                          │
│                                                                     │
│  1. 즉시 롤백                                                        │
│     - .env 변경: AUTH_MODE=LOCAL                                    │
│     - 서버 재시작                                                    │
│     - 기존 자체 인증으로 즉시 복구                                   │
│                                                                     │
│  2. 병행 운영 (선택적)                                                │
│     - AUTH_MODE=HYBRID 모드 구현                                    │
│     - SSO 실패 시 자동으로 LOCAL 폴백                                │
│     - 점진적 전환 가능                                               │
│                                                                     │
│  3. 데이터 보존                                                       │
│     - sso_id 컬럼은 유지 (재연동 대비)                               │
│     - 로컬 비밀번호는 SSO 전환 후에도 일정 기간 유지                 │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 요약

| 단계 | 내부 사용자 | 게스트 | 설정 |
|------|-----------|-------|------|
| **Phase 1** (현재) | LocalAuthStrategy | LocalGuestAuthStrategy | AUTH_MODE=LOCAL |
| **Phase 2** (SSO 도입) | SSOAuthStrategy | LocalGuestAuthStrategy | AUTH_MODE=SSO |
| **Phase 3** (전체 SSO) | SSOAuthStrategy | SSOGuestAuthStrategy | AUTH_MODE=SSO, GUEST_AUTH_MODE=SSO |

**핵심 포인트:**
1. **인터페이스 기반 설계**: 비즈니스 로직은 IAuthStrategy에만 의존
2. **환경 변수로 전략 선택**: 코드 변경 없이 인증 방식 전환
3. **점진적 전환**: 내부 사용자 → 게스트 순서로 단계적 도입
4. **즉시 롤백 가능**: 문제 발생 시 환경 변수만 변경하여 복구
